  File: README.md
  --- Start of README.md ---
# Motia.js Framework Repository

## Overview

This repository is dedicated to developing, refining, and testing the **Motia.js** framework. Motia.js is designed to simplify the creation of event-driven business automation workflows. The ultimate goal is to publish **Motia.js** as a standalone npm package, while the `src` directory serves as a sandbox for experimentation and implementation of real-world workflows.

### Aspirational Vision for Motia.js

Motia.js is a framework for building event-driven business automations that start simple but scale gracefully into production-grade systems. At its core, Motia.js helps define workflows as collections of small, testable components reacting to well-defined events. It:

- **Simplifies Workflow Design**: Quickly spin up logic, integrate external triggers, and schedule time-based tasks.
- **Encourages Maintainability**: Encourages incremental improvements and ensures high quality through testing and validation.
- **Scales**: Designed to grow from prototypes to enterprise-ready solutions.

## Repository Structure

### 1. **`motia.js`**

The heart of the repository, this file contains the core framework logic, including:

- **Event Bus**: Facilitates event-driven communication between components.
- **MotiaCore**: Central orchestrator that manages workflows, components, and events.
- **MotiaServer**: Integrates HTTP endpoints with the event-driven system.
- **MotiaScheduler**: Adds time-based triggers to workflows.
- **VersionControl**: Tracks workflow versions and metrics.
- **MotiaTest**: Utilities for testing components and workflows.

The goal of this repo is to refine this framework iteratively and eventually publish it as a package.

### 2. **`src`**

This directory implements and tests the functionality of `motia.js` through real-world use cases. It serves as both a sandbox and a validation environment.

#### Key Subdirectories:

- **`workflows`**: Contains example workflows demonstrating how to use the Motia.js framework.
  - **`policy-approval`**: A workflow for automating document approval based on policy rules. This includes components, scheduling, and logging mechanisms.
  - **`example-docs`**: Sample documents for testing workflows.
- **`traffic`**: HTTP traffic definitions used by `MotiaServer`.
- **`components`**: Modular pieces of workflows, each reacting to specific events.
- **`test-*` Scripts**: Scripts to validate external integrations, such as Google Drive and OpenAI connections.

### 3. **`package.json`**

Defines the npm scripts and dependencies required for the repository. Key scripts include:

- **`npm start`**: Initializes `MotiaCore`, `MotiaServer`, and `MotiaScheduler`.

### 4. **Utility Scripts**

- **`simulate-webhook.sh`**: Sends a mock webhook to simulate document uploads.
- **`test-drive-connection.js`**: Validates integration with Google Drive.
- **`test-openai-connection.js`**: Tests connectivity and functionality with OpenAI's GPT API.

## Workflow: Policy Approval

The `policy-approval` workflow demonstrates the capabilities of Motia.js by automating the review and approval of policy documents.

### Flow Overview:

1. **Document Upload**: A webhook triggers a `doc.uploaded` event.
2. **Fetch Content**: Document content is retrieved from Google Drive.
3. **Request Rules**: Compliance rules are fetched.
4. **Classify Document**: OpenAI GPT evaluates compliance and suggests changes if needed.
5. **Approval/Escalation**: Based on classification, the document is approved or escalated.
6. **Logging**: All events are logged for debugging.

## Key Concepts in Motia.js

- **Event-Driven Architecture**: Events trigger component actions, creating loosely coupled workflows.
- **Dynamic Loading**: Workflows, traffic, and schedules are loaded dynamically at runtime.
- **Testing Utilities**: `MotiaTest` provides mocks and tools for rigorous component testing.
- **External Integrations**: Works seamlessly with APIs like Google Drive and OpenAI.
- **Versioning**: Ensures workflows are incrementally improved and versioned.

## Goals for the Repository

1. Refine `motia.js` to meet production standards.
2. Test and validate the framework through example workflows in `src`.
3. Publish `motia.js` as an npm package with comprehensive documentation and examples.

## Setup Instructions

1. Clone the repository:

   ```bash
   git clone <repository_url>
   cd <repository_name>
   ```

2. Install dependencies:

   ```bash
   npm install
   ```

3. Set up environment variables:

   - `GOOGLE_CREDENTIALS`: JSON credentials for Google Drive API.
   - `OPENAI_API_KEY`: API key for OpenAI.
   - `POLICY_RULES_FILE_ID`: File ID of compliance rules on Google Drive.

4. Start the application:
   ```bash
   npm start
   ```

## Future Improvements

- Expand testing coverage for all components and workflows.
- Enhance scheduler to support cron expressions.
- Improve error handling and logging mechanisms.
- Add detailed documentation and examples for the npm package release.

## License

This project is licensed under [LICENSE_NAME].

---

This repository is a living document of the journey toward building and perfecting Motia.js. Feel free to explore, experiment, and contribute to its evolution!

  --- End of README.md ---

  File: package.json
  --- Start of package.json ---
{
  "name": "motia-monorepo",
  "private": true,
  "scripts": {
    "dev": "pnpm run -r --parallel dev",
    "build": "pnpm run -r build",
    "test": "pnpm run -r test",
    "flat": "node ./unrelated-tools/output-flat-repo.js",
    "drive-upload-hook": "./unrelated-tools/bin/drive-upload-hook.sh",
    "motia": "node packages/motia/src/cli/index.js"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.3.4",
    "concurrently": "^8.0.0",
    "dotenv": "^16.4.7",
    "ignore": "^6.0.2",
    "nodemon": "^3.0.0",
    "vite": "^6.0.0"
  },
  "packageManager": "pnpm@9.15.0+sha512.76e2379760a4328ec4415815bcd6628dee727af3779aaa4c914e3944156c4299921a89f976381ee107d41f12cfa4b66681ca9c718f0668fa0831ed4c6d8ba56c"
}

  --- End of package.json ---

  File: packages/motia/esbuild.config.js
  --- Start of esbuild.config.js ---
// packages/motia/esbuild.config.js
import * as esbuild from "esbuild";

const ctx = await esbuild.context({
  entryPoints: ["src/core/index.js"],
  bundle: true,
  platform: "node",
  format: "esm",
  outdir: "dist/node",
  external: [
    // Node.js built-ins
    "path",
    "fs",
    "url",
    "querystring",
    "http",
    "https",
    "stream",
    "zlib",
    "events",
    "crypto",
    "util",
    "buffer",
    "string_decoder",
    "async_hooks",
    // External dependencies
    "express",
    "body-parser",
    "react",
    "react-dom",
    "reactflow",
  ],
  sourcemap: true,
});

if (process.argv.includes("--watch")) {
  await ctx.watch();
} else {
  await ctx.rebuild();
  await ctx.dispose();
}

  --- End of esbuild.config.js ---

  File: packages/motia/package.json
  --- Start of package.json ---
{
  "name": "motia",
  "version": "0.1.0",
  "type": "module",
  "exports": {
    ".": {
      "import": "./src/index.js",
      "require": "./dist/node/index.js"
    },
    "./ui": {
      "import": "./src/ui/index.js",
      "require": "./dist/browser/ui.js"
    }
  },
  "sideEffects": [
    "./src/ui/*"
  ],
  "files": [
    "dist",
    "src"
  ],
  "scripts": {
    "dev": "concurrently \"node esbuild.config.js --watch\" \"vite build --watch\"",
    "build": "node esbuild.config.js && vite build"
  },
  "devDependencies": {
    "esbuild": "^0.24.0"
  },
  "dependencies": {
    "body-parser": "^1.20.3",
    "express": "^4.21.2"
  }
}

  --- End of package.json ---

  File: packages/motia/src/cli/commands/createComponent.js
  --- Start of createComponent.js ---
// packages/motia/src/cli/commands/createComponent.js
import fs from "fs";
import path from "path";
import { createIndexJs, createUiJsx } from "../templates.js";

export async function createComponent(workflowName, componentName) {
  if (!workflowName || !componentName) {
    throw new Error(
      "Usage: npx motia-cli create component <workflowName> <componentName>"
    );
  }

  const componentDir = path.join(
    process.cwd(),
    "playground", // Add playground to the path
    "src",
    "workflows",
    workflowName,
    "components",
    componentName
  );

  console.log("Creating component in:", componentDir);

  if (fs.existsSync(componentDir)) {
    throw new Error(`Component directory already exists: ${componentDir}`);
  }

  await fs.promises.mkdir(componentDir, { recursive: true });

  const indexJsPath = path.join(componentDir, "index.js");
  const uiJsxPath = path.join(componentDir, "ui.jsx");

  await fs.promises.writeFile(
    indexJsPath,
    createIndexJs(componentName),
    "utf8"
  );
  await fs.promises.writeFile(uiJsxPath, createUiJsx(componentName), "utf8");

  return componentDir;
}

  --- End of createComponent.js ---

  File: packages/motia/src/cli/index.js
  --- Start of index.js ---
#!/usr/bin/env node
import { createComponent } from "./commands/createComponent.js";

async function main() {
  const args = process.argv.slice(2);
  const command = args[0];

  if (command === "create" && args[1] === "component") {
    const workflowName = args[2];
    const componentName = args[3];

    try {
      const componentDir = await createComponent(workflowName, componentName);
      console.log(
        `Component ${componentName} created successfully at ${componentDir}`
      );
      console.log(
        "You can now add your logic and it will be rendered automatically by the Motia UI."
      );
    } catch (err) {
      console.error("Error:", err.message);
      process.exit(1);
    }
  } else {
    console.error(
      "Unknown command. Usage: npx motia-cli create component <workflowName> <componentName>"
    );
    process.exit(1);
  }
}

main().catch((err) => {
  console.error("Error:", err);
  process.exit(1);
});

  --- End of index.js ---

  File: packages/motia/src/cli/templates.js
  --- Start of templates.js ---
// packages/motia/src/cli/templates.js
import { toCamelCase, toPascalCase } from "./utils.js";

export function createIndexJs(componentName) {
  const safeHandlerName = toCamelCase(componentName) + "Handler";

  return `// index.js boilerplate
export const subscribe = ["example.my-event"];

export default async function ${safeHandlerName}(input, emit, eventType) {
  // Add your logic here
  console.log("Received event:", eventType, input);
}
`;
}

export function createUiJsx(componentName) {
  const safeComponentName = toPascalCase(componentName) + "Node";

  return `// ui.jsx boilerplate
import React from 'react';

export default function ${safeComponentName}({ data }) {
  return (
    <div className="node-container">
      <p className="node-title">{data.label || "${toPascalCase(
        componentName
      )}"}</p>
      <p className="node-subtitle">Subscribes to: {data.subscribe?.join(", ")}</p>
    </div>
  );
}
`;
}

  --- End of templates.js ---

  File: packages/motia/src/cli/utils.js
  --- Start of utils.js ---
export function toCamelCase(str) {
  return str.replace(/-([a-z])/g, (_, char) => char.toUpperCase());
}

export function toPascalCase(str) {
  const camel = toCamelCase(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}

  --- End of utils.js ---

  File: packages/motia/src/core/MessageBus.js
  --- Start of MessageBus.js ---
/**
 * In-Memory Message Bus Implementation
 * ------------------------------------
 * The InMemoryMessageBus provides a simple, local-only event bus for the Motia framework.
 * It manages event subscribers and publishes events to them. This bus operates fully in-memory,
 * making it ideal for development, testing, and lightweight deployments.
 *
 * Key Responsibilities:
 * - Store a list of subscribers (event handlers)
 * - When an event is published, deliver it to all subscribers that match the event type
 * - Handle errors in subscriber callbacks gracefully
 *
 * This class does not persist events or maintain any external state,
 * and is not suitable for production scenarios that require durability or scaling.
 */
export class InMemoryMessageBus {
  constructor() {
    this.subscribers = [];
  }

  async publish(event, options) {
    await Promise.all(
      this.subscribers.map((subscriber) =>
        subscriber(event, options).catch((error) => {
          console.error("Error in subscriber:", error);
        })
      )
    );
  }

  subscribe(handler) {
    this.subscribers.push(handler);
  }
}

  --- End of MessageBus.js ---

  File: packages/motia/src/core/MotiaCore.js
  --- Start of MotiaCore.js ---
import { fileURLToPath, pathToFileURL } from "url";
import path from "path";
import fs from "fs";
import { InMemoryMessageBus } from "./MessageBus.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Core Orchestrator: MotiaCore
 * ----------------------------
 * MotiaCore serves as the central orchestrator of the Motia framework. It manages the lifecycle
 * of workflows, components, and the event bus, acting as the heart of the entire system.
 *
 * Key Responsibilities:
 * - Initialize and configure the message bus (either in-memory or a provided one)
 * - Load and register workflows and their associated components
 * - Emit events into the system and deliver them to subscribed components
 *
 * MotiaCore provides the foundational logic that ties together components, events,
 * and workflows, enabling flexible, event-driven behavior throughout the application.
 */
export class MotiaCore {
  constructor() {
    this.messageBus = new InMemoryMessageBus();
    this.workflows = new Map();
    this.components = new Map();
  }

  describeWorkflows() {
    return {
      workflows: Array.from(this.workflows.keys()).map((workflowPath) => {
        const workflowName = path.basename(workflowPath);
        const componentEntries = Array.from(this.components.entries()).filter(
          ([compPath]) => compPath.includes(workflowName)
        );

        return {
          name: workflowName,
          components: componentEntries.map(([compPath, compModule]) => {
            const compDirName = path.basename(path.dirname(compPath));
            return {
              id: compDirName,
              subscribe: compModule.subscribe || [],
            };
          }),
        };
      }),
    };
  }

  async registerWorkflow(workflowPath) {
    try {
      const configPath = path.resolve(workflowPath, "config.js");
      const configModule = await import(pathToFileURL(configPath).href);
      this.workflows.set(workflowPath, configModule);
    } catch (error) {
      console.error(`Error registering workflow at ${workflowPath}:`, error);
    }
  }

  async registerComponent(componentPath) {
    try {
      // componentPath is absolute now
      const componentModule = await import(pathToFileURL(componentPath).href);
      if (componentModule.subscribe) {
        this.components.set(componentPath, componentModule.default);
      }
    } catch (error) {
      console.error(`Error registering component at ${componentPath}:`, error);
    }
  }

  async emit(event, options) {
    await this.messageBus.publish(event, options);
  }

  async initialize(options = {}) {
    const workflowPaths = options.workflowPaths || ["./src/workflows"];
    this.messageBus = options.messageBus || new InMemoryMessageBus();

    this.workflows = new Map();
    this.components = new Map();

    // Convert workflowPaths to absolute
    const absoluteWorkflowPaths = workflowPaths.map((p) => path.resolve(p));

    // Load all workflows
    for (const wPath of absoluteWorkflowPaths) {
      const workflowFiles = await this.findWorkflowFiles(wPath);
      for (const file of workflowFiles) {
        await this.registerWorkflow(file);
      }
    }

    // Load all components from these workflows
    const componentFiles = await this.findComponentFiles(absoluteWorkflowPaths);
    for (const file of componentFiles) {
      await this.registerComponent(file);
    }

    // Subscribe components to message bus
    for (const [id, component] of this.components.entries()) {
      const moduleUrl = pathToFileURL(id).href;
      const module = await import(moduleUrl);
      if (module.subscribe) {
        for (const eventPattern of module.subscribe) {
          this.messageBus.subscribe(async (event, opts) => {
            if (this.eventMatchesPattern(event.type, eventPattern)) {
              await component(
                event.data,
                (e) => this.emit(e, opts),
                event.type
              );
            }
          });
        }
      }
    }
  }

  async findWorkflowFiles(basePath) {
    const workflows = [];
    try {
      const entries = await fs.promises.readdir(basePath, {
        withFileTypes: true,
      });
      for (const entry of entries) {
        if (entry.isDirectory()) {
          const workflowPath = path.join(basePath, entry.name);
          const files = await fs.promises.readdir(workflowPath);
          if (files.includes("config.js") && files.includes("version.json")) {
            // Return absolute path
            workflows.push(path.resolve(workflowPath));
          }
        }
      }
    } catch (error) {
      console.error("Error finding workflow files:", error);
    }
    return workflows;
  }

  async findComponentFiles(paths) {
    const components = [];
    for (const basePath of paths) {
      try {
        const workflowDirs = await fs.promises.readdir(basePath, {
          withFileTypes: true,
        });

        for (const workflowDir of workflowDirs) {
          if (!workflowDir.isDirectory()) continue;

          const componentsPath = path.join(
            basePath,
            workflowDir.name,
            "components"
          );
          try {
            await this.searchComponents(componentsPath, components);
          } catch {
            // If components dir doesn't exist, skip
          }
        }
      } catch (error) {
        console.error("Error finding component files:", error);
      }
    }
    return components.map((c) => path.resolve(c));
  }

  async searchComponents(dir, components) {
    let entries;
    try {
      entries = await fs.promises.readdir(dir, { withFileTypes: true });
    } catch {
      return;
    }

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        await this.searchComponents(fullPath, components);
      } else if (
        entry.name.endsWith(".js") &&
        !entry.name.endsWith(".test.js")
      ) {
        components.push(fullPath);
      }
    }
  }

  eventMatchesPattern(eventType, pattern) {
    if (pattern === "*") return true;
    if (pattern === eventType) return true;
    if (pattern.endsWith(".*")) {
      const prefix = pattern.slice(0, -2);
      return eventType.startsWith(prefix);
    }
    return false;
  }
}

  --- End of MotiaCore.js ---

  File: packages/motia/src/core/MotiaScheduler.js
  --- Start of MotiaScheduler.js ---
import fs from "fs";
import path from "path";
import { pathToFileURL } from "url";

/**
 * Time-Based Scheduling: MotiaScheduler
 * -------------------------------------
 * MotiaScheduler introduces time-based triggers into the Motia framework. It periodically emits
 * events based on defined schedules, enabling recurring or delayed actions.
 *
 * Key Responsibilities:
 * - Parse and manage time-based configurations (e.g., "1h", "30m")
 * - Set intervals or timers and emit corresponding events at defined intervals
 * - Integrate with workflows that depend on periodic checks or escalations
 *
 * This class allows workflows to incorporate scheduled behavior, such as escalating documents
 * if not approved within a certain time.
 */
export class MotiaScheduler {
  constructor() {
    this.schedules = new Map();
    this.activeJobs = new Map();
  }

  async findScheduleFiles(paths) {
    const fsPromises = fs.promises;
    const schedules = [];

    const searchSchedules = async (dir) => {
      let entries;
      try {
        entries = await fsPromises.readdir(dir, { withFileTypes: true });
      } catch {
        return;
      }

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
          await searchSchedules(fullPath);
        } else if (
          entry.name.endsWith(".js") &&
          !entry.name.endsWith(".test.js")
        ) {
          schedules.push(fullPath);
        }
      }
    };

    for (const basePath of paths) {
      const schedulerPath = path.join(basePath, "scheduler");
      await searchSchedules(schedulerPath);
    }

    return schedules;
  }

  async initialize(core, schedulePaths = ["./src/workflows"]) {
    this.core = core;
    const scheduleFiles = await this.findScheduleFiles(
      schedulePaths.map((p) => path.resolve(p))
    );

    for (const file of scheduleFiles) {
      const scheduleModule = await import(pathToFileURL(file).href);
      if (scheduleModule.default) {
        const id = file.replace(/\.[jt]s$/, "");
        this.schedules.set(id, scheduleModule.default);
      }
    }
  }

  start() {
    this.schedules.forEach((schedule, id) => {
      const interval = this.parseSchedule(schedule.interval);

      const job = setInterval(() => {
        this.core.emit(
          {
            type: schedule.eventType,
            data: {
              scheduledAt: new Date().toISOString(),
              scheduleId: id,
            },
          },
          {
            metadata: {
              source: "scheduler",
              scheduleId: id,
            },
          }
        );
      }, interval);

      this.activeJobs.set(id, job);
    });
  }

  stop() {
    this.activeJobs.forEach((job) => {
      clearInterval(job);
    });
    this.activeJobs.clear();
  }

  parseSchedule(schedule) {
    const timeRegex = /^(\d+)(s|m|h|d)$/;
    const match = schedule.match(timeRegex);
    if (match) {
      const [, value, unit] = match;
      const num = parseInt(value, 10);
      switch (unit) {
        case "s":
          return num * 1000;
        case "m":
          return num * 60 * 1000;
        case "h":
          return num * 60 * 60 * 1000;
        case "d":
          return num * 24 * 60 * 60 * 1000;
        default:
          return 0;
      }
    }

    if (schedule.split(" ").length === 5) {
      // TODO: cron parsing
      return 60 * 60 * 1000;
    }

    throw new Error(`Invalid schedule format: ${schedule}`);
  }
}

  --- End of MotiaScheduler.js ---

  File: packages/motia/src/core/MotiaServer.js
  --- Start of MotiaServer.js ---
import express from "express";
import bodyParser from "body-parser";
import fs from "fs";
import path from "path";
import { fileURLToPath, pathToFileURL } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class MotiaServer {
  constructor() {
    this.traffic = new Map();
    this.express = express();
    this.express.use(bodyParser.json());
  }

  async findTrafficFiles(paths) {
    const trafficFiles = [];

    const searchTraffic = async (dir) => {
      let entries;
      try {
        entries = await fs.promises.readdir(dir, { withFileTypes: true });
      } catch {
        return;
      }

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
          await searchTraffic(fullPath);
        } else if (
          entry.name.endsWith(".js") &&
          !entry.name.endsWith(".test.js")
        ) {
          trafficFiles.push(fullPath);
        }
      }
    };

    for (const basePath of paths) {
      const absolutePath = path.resolve(basePath);
      await searchTraffic(absolutePath);
    }

    console.log("Found traffic files:", trafficFiles);
    return trafficFiles;
  }

  async initialize(core, trafficPaths = ["./traffic/inbound"]) {
    this.core = core;
    const trafficFiles = await this.findTrafficFiles(trafficPaths);

    for (const trafficFile of trafficFiles) {
      const trafficModule = await import(pathToFileURL(trafficFile));
      const trafficConfigs = Array.isArray(trafficModule.default)
        ? trafficModule.default
        : [trafficModule.default];

      for (const config of trafficConfigs) {
        this.registerTraffic(config);
      }
    }

    // Register routes for each traffic config
    this.traffic.forEach((config, routePath) => {
      this.express[config.method.toLowerCase()](routePath, async (req, res) => {
        try {
          await this.handleRequest(req, res);
        } catch (error) {
          res.status(500).json({ error: error.message });
        }
      });
    });

    // Serve static files
    this.express.use(express.static(path.join(__dirname, "../dist")));

    // Return workflow descriptions
    this.express.get("/api/workflows", (req, res) => {
      res.json(this.core.describeWorkflows());
    });

    // Catch-all route to serve index.html
    this.express.get("*", (req, res) => {
      res.sendFile(path.join(__dirname, "../dist/index.html"));
    });

    const port = process.env.PORT || 3000;
    this.express.listen(port, () => {
      console.log(`Server listening on port ${port}`);
    });
  }

  async handleRequest(req, res) {
    const traffic = this.traffic.get(req.path);
    if (!traffic) {
      res.status(404).json({ error: "Traffic not found" });
      return;
    }

    try {
      if (traffic.authorize) {
        await traffic.authorize(req);
      }

      const event = await traffic.transform(req);

      await this.core.emit(event, {
        traceId: req.headers["x-trace-id"],
        metadata: {
          source: "http",
          path: req.path,
          method: req.method,
        },
      });

      res.status(200).json({ success: true, eventType: event.type });
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }

  registerTraffic(config) {
    if (!config.path || !config.method || !config.transform) {
      throw new Error("Invalid traffic configuration");
    }

    const routePath = config.path.startsWith("/")
      ? config.path
      : `/${config.path}`;
    this.traffic.set(routePath, config);
  }
}

  --- End of MotiaServer.js ---

  File: packages/motia/src/core/MotiaTest.js
  --- Start of MotiaTest.js ---
/**
 * Testing Utilities: MotiaTest
 * ----------------------------
 * MotiaTest offers testing utilities to validate components, thresholds, and LLM logic within the Motia framework.
 * It provides mock emit functions, component test helpers, and performance test runners.
 *
 * Key Responsibilities:
 * - Create mock emit functions to simulate event emission in tests
 * - Provide helper functions for component-level testing and threshold verification
 * - Offer utilities for load testing and accuracy measurement of LLM outputs
 *
 * This class simplifies and standardizes how developers test their Motia-based workflows, ensuring reliability and correctness.
 */
export class MotiaTest {
  static mockEmit() {
    const mock = (...args) => {};
    mock.mock = { calls: [] };
    const wrapper = (event, options) => {
      mock.mock.calls.push([event, options]);
    };
    return wrapper;
  }

  static createComponentTest(component, options) {
    return async (input, emit) => {
      const mockEmit = emit || MotiaTest.mockEmit();
      // If mocks needed, must be handled outside this method for ESM.
      await component(input, mockEmit, "test.event");
    };
  }

  static createThresholdTest(component, options) {
    return async () => {
      const results = {
        accuracy: 0,
        latency: { p95: 0, p99: 0 },
        successRate: 0,
        totalRuns: 0,
        errors: [],
      };

      const runTest = async (input) => {
        const startTime = Date.now();
        try {
          const mockEmit = MotiaTest.mockEmit();
          await component(input, mockEmit, "test.event");
          results.totalRuns++;
          return Date.now() - startTime;
        } catch (error) {
          results.errors.push(
            error instanceof Error ? error : new Error(String(error))
          );
          return null;
        }
      };

      if (options.loadTestOptions) {
        const { rps, duration } = options.loadTestOptions;
        const durationMs = parseDuration(duration);
        const interval = 1000 / rps;
        const endTime = Date.now() + durationMs;
        const latencies = [];

        while (Date.now() < endTime) {
          for (const data of options.testData) {
            const latency = await runTest(data);
            if (latency) latencies.push(latency);
            await sleep(interval);
          }
        }

        latencies.sort((a, b) => a - b);
        results.latency.p95 = latencies[Math.floor(latencies.length * 0.95)];
        results.latency.p99 = latencies[Math.floor(latencies.length * 0.99)];
      } else {
        for (const data of options.testData) {
          await runTest(data);
        }
      }

      results.successRate =
        (results.totalRuns - results.errors.length) / results.totalRuns;
      return results;
    };
  }

  static createLLMTest(component, options) {
    return async () => {
      const results = {
        accuracy: 0,
        consistency: 0,
        averageConfidence: 0,
        edgeCaseResults: [],
        errors: [],
      };

      for (const data of options.testData) {
        const outputs = [];
        for (let i = 0; i < (options.consistencyRuns || 1); i++) {
          const mockEmit = MotiaTest.mockEmit();
          try {
            await component(data, mockEmit, "test.event");
            outputs.push(mockEmit.mock.calls[0]?.[0]?.data);
          } catch (error) {
            results.errors.push(
              error instanceof Error ? error : new Error(String(error))
            );
          }
        }

        if (outputs.length > 1) {
          results.consistency += calculateConsistency(outputs);
        }
      }

      if (options.edgeCases) {
        for (const edgeCase of options.edgeCases) {
          const mockEmit = MotiaTest.mockEmit();
          try {
            await component(edgeCase.input, mockEmit, "test.event");
            const output = mockEmit.mock.calls[0]?.[0]?.data;
            results.edgeCaseResults.push({
              input: edgeCase.input,
              expected: edgeCase.expect,
              actual: output,
              passed: output === edgeCase.expect,
            });
          } catch (error) {
            results.errors.push(
              error instanceof Error ? error : new Error(String(error))
            );
          }
        }
      }

      results.accuracy = calculateAccuracy(results.edgeCaseResults);
      if (options.consistencyRuns) {
        results.consistency /= options.testData.length;
      }

      return results;
    };
  }
}

  --- End of MotiaTest.js ---

  File: packages/motia/src/core/index.js
  --- Start of index.js ---
export * from "./MessageBus.js";
export * from "./MotiaCore.js";
export * from "./MotiaServer.js";
export * from "./MotiaScheduler.js";
export * from "./MotiaTest.js";

// Also export the utility functions if they're needed externally
export function defineTraffic(config) {
  return config;
}

export function defineRoute(config) {
  return config;
}

  --- End of index.js ---

  File: packages/motia/src/index.js
  --- Start of index.js ---
// Core functionality
export * from "./core/MotiaCore.js";
export * from "./core/MotiaServer.js";
export * from "./core/MotiaScheduler.js";
export * from "./core/MotiaTest.js";
export * from "./core/MessageBus.js";

// Helper functions
export { defineTraffic, defineRoute } from "./core/index.js";

// Note: UI components are exported separately via './ui' entry point
// CLI is accessed via the bin entry point

  --- End of index.js ---

  File: packages/motia/src/ui/MotiaUi.js
  --- Start of MotiaUi.js ---
export class MotiaUi {
  static nodeTypes = {};

  static registerNodeTypesFromGlob(modules) {
    const nodeTypes = {};
    for (const path in modules) {
      const match = path.match(/components\/([^/]+)\/ui\.jsx$/);
      if (match) {
        const componentId = match[1];
        nodeTypes[componentId] = modules[path].default;
      }
    }
    MotiaUi.nodeTypes = { ...MotiaUi.nodeTypes, ...nodeTypes };
    console.log("MotiaUi bootstrap completed. NodeTypes:", MotiaUi.nodeTypes);
  }

  static getNodeTypes() {
    return MotiaUi.nodeTypes;
  }
}

  --- End of MotiaUi.js ---

  File: packages/motia/src/ui/hooks/useMotiaFlow.js
  --- Start of useMotiaFlow.js ---
import { useEffect, useState } from "react";

export function useMotiaFlow() {
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function loadWorkflows() {
      try {
        const res = await fetch("/api/workflows");
        if (!res.ok) {
          throw new Error(`Failed to fetch workflows: ${res.statusText}`);
        }
        const data = await res.json();
        const workflow = data.workflows?.[0];

        if (!workflow) {
          throw new Error("No workflows found");
        }

        const transformedNodes = workflow.components.map((comp, idx) => ({
          id: comp.id,
          type: comp.id,
          position: { x: idx * 200, y: 100 },
          data: { label: comp.id, subscribe: comp.subscribe },
        }));

        setNodes(transformedNodes);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }

    loadWorkflows();
  }, []);

  return { nodes, edges, loading, error };
}

  --- End of useMotiaFlow.js ---

  File: packages/motia/src/ui/index.js
  --- Start of index.js ---
// packages/motia/src/ui/index.js
import { MotiaUi } from "./MotiaUi.js";
import { useMotiaFlow } from "./hooks/useMotiaFlow.js";

// Export as named exports
export { MotiaUi, useMotiaFlow };

// Also provide a default export if needed
export default {
  MotiaUi,
  useMotiaFlow,
};

  --- End of index.js ---

  File: packages/motia/src/ui/styles.css
  --- Start of styles.css ---
.node-container {
    padding: 12px 16px;
    border-radius: 8px;
    background-color: #1e1e1e;
    color: #ddd;
    border: 1px solid #333;
    font-family: 'Inter', sans-serif;
    font-size: 14px;
  }
  
  .node-title {
    font-size: 16px;
    font-weight: 600;
    margin: 0 0 8px 0;
  }
  
  .node-subtitle {
    margin: 0;
    font-size: 13px;
    color: #555;
  }
  
  .react-flow__controls {
    background-color: #2c2c2c;
    color: #fff;
  }
  --- End of styles.css ---

  File: packages/motia/vite.config.js
  --- Start of vite.config.js ---
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  build: {
    lib: {
      entry: "src/ui/index.js",
      formats: ["es"],
      fileName: "ui",
    },
    outDir: "dist/browser",
    rollupOptions: {
      external: ["react", "react-dom", "reactflow"],
    },
  },
  plugins: [react()],
});

  --- End of vite.config.js ---

  File: playground/index.html
  --- Start of index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Motia UI</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" />
</head>
<body>
  <div id="root"></div>
  <script type="module" src="/src/ui/index.jsx"></script>
</body>
</html>
  --- End of index.html ---

  File: playground/package.json
  --- Start of package.json ---
{
  "name": "motia-playground",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "concurrently \"nodemon -w ../motia/dist -w src src/index.js\" \"vite\"",
    "build": "vite build"
  },
  "dependencies": {
    "dotenv": "^16.4.7",
    "googleapis": "^144.0.0",
    "motia": "workspace:*",
    "openai": "^4.76.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "reactflow": "^11.11.4"
  }
}

  --- End of package.json ---

  File: playground/src/index.js
  --- Start of index.js ---
import "dotenv/config";
import path from "path";
import { fileURLToPath } from "url";
import { MotiaCore, MotiaServer, MotiaScheduler } from "motia";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function main() {
  const core = new MotiaCore();
  const server = new MotiaServer();
  const scheduler = new MotiaScheduler();

  console.log("Initializing Motia...");

  // Initialize with correct workflow paths
  await core.initialize({
    workflowPaths: [path.join(__dirname, "workflows")],
  });

  // Initialize server with correct traffic paths - note the src/traffic/inbound path
  await server.initialize(core, [path.join(__dirname, "traffic/inbound")]);

  await scheduler.initialize(core, [path.join(__dirname, "workflows")]);
  scheduler.start();

  console.log("Workflow initialized. Listening for events...");
}

main().catch(console.error);

  --- End of index.js ---

  File: playground/src/traffic/inbound/google-drive/human-feedback.js
  --- Start of human-feedback.js ---
import { defineTraffic } from "motia";

export default defineTraffic({
  path: "/api/docs/humanFeedback",
  method: "POST",
  transform: (req) => {
    const { fileId, action } = req.body;

    if (!fileId || !action) {
      throw new Error("fileId and action are required");
    }

    if (!["AUTO_FIX", "APPROVE", "REJECT"].includes(action)) {
      throw new Error("Invalid action. Must be AUTO_FIX, APPROVE, or REJECT");
    }

    return {
      type: "doc.human_action",
      data: {
        fileId,
        action,
        timestamp: new Date().toISOString(),
      },
    };
  },
});

  --- End of human-feedback.js ---

  File: playground/src/traffic/inbound/google-drive/simulate-classification.js
  --- Start of simulate-classification.js ---
import { defineTraffic } from "motia";

export default defineTraffic({
  path: "/api/simulateClassification",
  method: "POST",
  transform: async (req) => {
    const { testDocContent } = req.body;
    if (!testDocContent) {
      throw new Error("testDocContent is required");
    }

    // We simulate that the rules have been fetched and content is ready for classification.
    // Emitting `doc.ready_for_classification` bypasses steps you'd normally hit, but it's useful for testing.
    return {
      type: "doc.ready_for_classification",
      data: {
        originalFileId: "TEST_DOC_ID",
        originalDocContent: testDocContent,
        docContent: `
Organization Policy Rules - Q4 Update
General Compliance:
All policy documents must not conflict with existing corporate policies.
All financial limits mentioned must be within the approved budget levels set forth by the Finance Department.
Any mention of new categories of expenses or changes in approval processes require explicit reference to existing policies or must be explicitly flagged for human review.
Expense & Approval Rules:
Any increase in reimbursement thresholds above $500 requires human review and approval before finalization.
Introducing new expense categories (like “Executive Travel” or “Personal Subscriptions”) must be escalated for legal and managerial review.
Language suggesting that employees are not required to keep receipts for expenses is prohibited and triggers human approval.
Compliance & Legal Requirements:
Any policy referencing legal frameworks (e.g., HIPAA, PCI-DSS, SOX compliance) must be explicitly marked for human review if changing or introducing new compliance clauses.
Removing or weakening any existing compliance requirement must trigger a review process.
Urgency & Priority:
If the document uses words like “urgent” or “immediately” to redefine operational processes without justification, it must be checked by a human approver.
Summary:
All changes that introduce new rules, increase financial thresholds, alter compliance terms, or suggest major operational changes require human review. Minor clarifications, rewording without altering rules, or adding examples that do not break these conditions can be auto-approved.
        `,
      },
    };
  },
});

  --- End of simulate-classification.js ---

  File: playground/src/traffic/inbound/google-drive/webhooks.js
  --- Start of webhooks.js ---
import { defineTraffic } from "motia";

export default defineTraffic({
  path: "/api/docs/uploaded",
  method: "POST",
  transform: (req) => ({
    type: "doc.uploaded",
    data: {
      fileId: req.body.fileId,
      fileName: req.body.fileName,
    },
  }),
});

  --- End of webhooks.js ---

  File: playground/src/traffic/outbound/google-docs-api.js
  --- Start of google-docs-api.js ---
import { google } from "googleapis";

export async function updateDocument(fileId, requests) {
  const credentials = JSON.parse(process.env.GOOGLE_CREDENTIALS);
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: [
      "https://www.googleapis.com/auth/documents",
      "https://www.googleapis.com/auth/drive",
    ],
  });

  const docsClient = google.docs({
    version: "v1",
    auth: await auth.getClient(),
  });

  await docsClient.documents.batchUpdate({
    documentId: fileId,
    requestBody: { requests },
  });
}

  --- End of google-docs-api.js ---

  File: playground/src/traffic/outbound/google-drive-api.js
  --- Start of google-drive-api.js ---
import { google } from "googleapis";

export async function getDocContent(fileId) {
  const credentials = JSON.parse(process.env.GOOGLE_CREDENTIALS || "{}");
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/drive.readonly"],
  });
  const drive = google.drive({ version: "v3", auth: await auth.getClient() });

  const res = await drive.files.export(
    { fileId, mimeType: "text/plain" },
    { responseType: "text" }
  );

  return res.data;
}

  --- End of google-drive-api.js ---

  File: playground/src/traffic/outbound/openai-api.js
  --- Start of openai-api.js ---
import OpenAI from "openai";

const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

export async function runChatCompletion(messages, options = {}) {
  const response = await client.chat.completions.create({
    model: options.model || "gpt-3.5-turbo",
    messages,
    max_tokens: options.max_tokens || 600,
    temperature: options.temperature ?? 0,
  });

  return response;
}

  --- End of openai-api.js ---

  File: playground/src/ui/App.jsx
  --- Start of App.jsx ---
import React from 'react';
import ReactFlow, { Controls, Background } from 'reactflow';
import { MotiaUi, useMotiaFlow } from 'motia/ui';
import 'reactflow/dist/style.css';
import './motia-ui.js';
import './styles.css';

export default function App() {
  const { nodes, edges, loading, error } = useMotiaFlow();
  const nodeTypes = MotiaUi.getNodeTypes();

  if (loading) return <div>Loading workflows...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div style={{ width: '100vw', height: '100vh' }}>
      <ReactFlow nodes={nodes} edges={edges} nodeTypes={nodeTypes} fitView>
        <Background variant="lines" gap={20} size={1} color="#555" />
        <Controls />
      </ReactFlow>
    </div>
  );
}
  --- End of App.jsx ---

  File: playground/src/ui/index.jsx
  --- Start of index.jsx ---
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App.jsx';

const container = document.getElementById('root');
const root = createRoot(container);
root.render(<App />);
  --- End of index.jsx ---

  File: playground/src/ui/motia-ui.js
  --- Start of motia-ui.js ---
// playground/src/ui/motia-ui.js
import { MotiaUi } from "motia/ui";

// Run glob in frontend environment
const modules = import.meta.glob("../workflows/**/components/**/ui.jsx", {
  eager: true,
});

console.log("Registering node types...");
MotiaUi.registerNodeTypesFromGlob(modules);

// Export for use in other files
export { MotiaUi };

  --- End of motia-ui.js ---

  File: playground/src/ui/styles.css
  --- Start of styles.css ---

body {
  background-color: #121212;
  margin: 0;
}

#root {
  width: 100vw;
  height: 100vh;
  background-color: #121212;
}


.node-container {
  padding: 12px 16px;
  border-radius: 8px;
  background-color: #1e1e1e;
  color: #ddd;
  border: 1px solid #333;
  font-family: 'Inter', sans-serif;
  font-size: 14px;
}
  
  .node-title {
    font-size: 16px;
    font-weight: 600;
    margin: 0 0 8px 0;
  }
  
  .node-subtitle {
    margin: 0;
    font-size: 13px;
    color: #555;
  }

  .react-flow__controls {
    background-color: #2c2c2c;
    color: #fff;
  }
  --- End of styles.css ---

  File: playground/src/workflows/policy-approval/components/doc-handler/index.js
  --- Start of index.js ---
import { getDocContent } from "../../../../traffic/outbound/google-drive-api.js";

export const subscribe = ["doc.needs_approval", "doc.updated", "doc.escalate"];

export default async function docHandler(input, emit, eventType) {
  const { fileId } = input;

  if (eventType === "doc.updated") {
    const content = await getDocContent(fileId);
    if (content.includes("Status: Approved")) {
      emit({ type: "doc.human_reviewed", data: { fileId } });
      emit({ type: "doc.approved", data: { fileId } });
      emit({ type: "doc.finalized", data: { fileId, result: "Approved" } });
    }
  }

  if (eventType === "doc.escalate") {
    emit({ type: "doc.finalized", data: { fileId, result: "Escalated" } });
  }
}

  --- End of index.js ---

  File: playground/src/workflows/policy-approval/components/doc-handler/ui.jsx
  --- Start of ui.jsx ---
export default function LlmClassifierNode({ data }) {
  return (
    <div className="node-container">
      <p className="node-title">{data.label}</p>
      <p className="node-subtitle">Subscribes to: {data.subscribe.join(', ') || 'None'}</p>
      <p className="node-subtitle">Some Text</p>
    </div>
  );
}
  --- End of ui.jsx ---

  File: playground/src/workflows/policy-approval/components/doc-updater/index.js
  --- Start of index.js ---
import { updateDocument } from "../../../../traffic/outbound/google-docs-api.js";

export const subscribe = ["doc.needs_approval"];

export default async function docUpdater(input, emit) {
  const { fileId, recommendations } = input;

  const requests = [
    {
      replaceAllText: {
        containsText: { text: "Document Status: Draft", matchCase: true },
        replaceText: "Document Status: LLM Reviewed",
      },
    },
    {
      replaceAllText: {
        containsText: { text: "Recommendation:", matchCase: true },
        replaceText: `Recommendation: ${
          recommendations || "No recommendations."
        }`,
      },
    },
  ];

  await updateDocument(fileId, requests);
}

  --- End of index.js ---

  File: playground/src/workflows/policy-approval/components/doc-updater/ui.jsx
  --- Start of ui.jsx ---
import React from 'react';

export default function DocUpdaterNode({ data }) {
  return (
    <div className="node-container">
      <p className="node-title">{data.label}</p>
      <p className="node-subtitle">Subscribes to: {data.subscribe.join(', ') || 'None'}</p>
      <p className="node-subtitle">Some Text</p>
    </div>
  );
}
  --- End of ui.jsx ---

  File: playground/src/workflows/policy-approval/components/doc-upload-trigger/index.js
  --- Start of index.js ---
export const subscribe = ["doc.uploaded"];

const docUploadTrigger = async (input, emit) => {
  const { fileId } = input;
  emit({
    type: "doc.fetch_requested",
    data: {
      fileId,
      originalFileId: fileId,
      targetEvent: "doc.content_fetched",
    },
  });
};

export default docUploadTrigger;

  --- End of index.js ---

  File: playground/src/workflows/policy-approval/components/doc-upload-trigger/ui.jsx
  --- Start of ui.jsx ---
import React, { useState } from 'react';

export default function DocUploadTriggerNode({ data }) {
  const subscribedEvents = data.subscribe.join(', ') || 'None';

  const [fileId, setFileId] = useState("SAMPLE_FILE_ID");
  const [fileName, setFileName] = useState("Sample Document");

  const handleSimulateUpload = async () => {
    const response = await fetch('/api/docs/uploaded', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ fileId, fileName })
    });

    if (response.ok) {
      alert(`Simulated doc.uploaded event for ${fileName} (${fileId})`);
    } else {
      const err = await response.json();
      alert("Simulation failed: " + err.error);
    }
  };

  return (
    <div className="node-container">
      <p className="node-title">{data.label}</p>
      <p className="node-subtitle">Subscribes to: {subscribedEvents}</p>
      
      <h4 style={{ marginTop: '16px', fontWeight: '600' }}>Test the Initial Trigger</h4>
      <div style={{ marginBottom: '8px' }}>
        <label style={{ display: 'block', marginBottom: '4px' }}>File ID:</label>
        <input 
          type="text"
          value={fileId}
          onChange={(e) => setFileId(e.target.value)}
          style={{ width: '100%' }}
        />
      </div>
      <div style={{ marginBottom: '8px' }}>
        <label style={{ display: 'block', marginBottom: '4px' }}>File Name:</label>
        <input 
          type="text"
          value={fileName}
          onChange={(e) => setFileName(e.target.value)}
          style={{ width: '100%' }}
        />
      </div>

      <button onClick={handleSimulateUpload} style={{ padding: '8px 12px', cursor: 'pointer' }}>
        Simulate Doc Upload
      </button>
    </div>
  );
}

  --- End of ui.jsx ---

  File: playground/src/workflows/policy-approval/components/drive-doc-fetcher/index.js
  --- Start of index.js ---
import { getDocContent } from "../../../../traffic/outbound/google-drive-api.js";

export const subscribe = ["doc.fetch_requested"];

export default async function driveDocFetcher(input, emit) {
  const { fileId, targetEvent, ...rest } = input;
  const docContent = await getDocContent(fileId);

  emit({
    type: targetEvent,
    data: { fileId, docContent, ...rest },
  });
}

  --- End of index.js ---

  File: playground/src/workflows/policy-approval/components/drive-doc-fetcher/ui.jsx
  --- Start of ui.jsx ---
import React from 'react';

export default function driveDocFetcherNode({ data }) {
  return (
    <div className="node-container">
      <p className="node-title">{data.label}</p>
      <p className="node-subtitle">Subscribes to: {data.subscribe.join(', ') || 'None'}</p>
      <p className="node-subtitle">Some Text</p>
    </div>
  );
}
  --- End of ui.jsx ---

  File: playground/src/workflows/policy-approval/components/llm-classifier/index.js
  --- Start of index.js ---
import { runChatCompletion } from "../../../../traffic/outbound/openai-api.js";

export const subscribe = ["doc.ready_for_classification"];

export default async function llmClassifier(input, emit) {
  const {
    originalDocContent,
    docContent: rulesContent,
    originalFileId,
  } = input;

  const prompt = `
Given these policy rules:
${rulesContent}

And this new policy document:
${originalDocContent}

1) Determine if the new document fully complies with the rules.
   If fully compliant, answer with:
   STATUS: AUTO_APPROVE
   SUMMARY: <brief summary>

   If not compliant, answer with:
   STATUS: NEEDS_APPROVAL
   SUMMARY: <brief explanation>

2) If STATUS is NEEDS_APPROVAL, also provide:
   RECOMMENDATIONS: <list suggestions on how to modify the document to comply with the rules>
`;

  const response = await runChatCompletion([{ role: "user", content: prompt }]);
  const text = response.choices[0].message.content.trim();

  const statusMatch = text.match(/STATUS:\s*(AUTO_APPROVE|NEEDS_APPROVAL)/i);
  const summaryMatch = text.match(/SUMMARY:\s*(.*)/i);
  const recommendationsMatch = text.match(/RECOMMENDATIONS:\s*(.*)/is);

  let autoApproved = false;
  let summary = "No summary found.";
  let recommendations = "";

  if (statusMatch) {
    autoApproved = statusMatch[1].toUpperCase() === "AUTO_APPROVE";
  }
  if (summaryMatch) {
    summary = summaryMatch[1].trim();
  }
  if (!autoApproved && recommendationsMatch) {
    recommendations = recommendationsMatch[1].trim();
  }

  if (autoApproved) {
    emit({
      type: "doc.auto_approved",
      data: { fileId: originalFileId, summary },
    });
  } else {
    emit({
      type: "doc.needs_approval",
      data: { fileId: originalFileId, summary, recommendations },
    });
  }
}

  --- End of index.js ---

  File: playground/src/workflows/policy-approval/components/llm-classifier/ui.jsx
  --- Start of ui.jsx ---
import React, { useState } from 'react';

export default function LlmClassifierNode({ data }) {
  const subscribedEvents = data.subscribe.join(', ') || 'None';

  const [prompt, setPrompt] = useState(`
Given these policy rules:
{{rules}}

And this new policy document:
{{document}}

1) Determine compliance...
2) Provide recommendations...
`.trim());

  const [testDocContent, setTestDocContent] = useState("This is a sample doc content that needs testing.");

  const handleTestClassification = async () => {
    console.log(testDocContent)
    const response = await fetch('/api/simulateClassification', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ testDocContent })
    });

    if (response.ok) {
      alert("Simulated classification event with your test doc content. Check logs or downstream output for results.");
    } else {
      const err = await response.json();
      alert("Classification simulation failed: " + err.error);
    }
  };

  return (
    <div className="node-container">
      <p className="node-title">{data.label}</p>
      <p className="node-subtitle">Subscribes to: {subscribedEvents}</p>

      <h4 style={{ marginTop: '16px', fontWeight: '600' }}>LLM Prompt Configuration</h4>
      <p style={{ margin: '4px 0' }}>Edit the prompt template used by the classifier:</p>
      <textarea 
        value={prompt} 
        onChange={(e) => setPrompt(e.target.value)} 
        style={{ width: '100%', height: '150px', marginBottom: '8px' }} 
      />

      <h4 style={{ marginTop: '16px', fontWeight: '600' }}>Test Classification</h4>
      <p style={{ margin: '4px 0' }}>Enter test document content:</p>
      <textarea 
        value={testDocContent} 
        onChange={(e) => setTestDocContent(e.target.value)} 
        style={{ width: '100%', height: '100px', marginBottom: '8px' }} 
      />

      <button onClick={handleTestClassification} style={{ padding: '8px 12px', cursor: 'pointer' }}>
        Run Test Classification
      </button>
    </div>
  );
}

  --- End of ui.jsx ---

  File: playground/src/workflows/policy-approval/components/policy-approval-logger/index.js
  --- Start of index.js ---
export const subscribe = ["*"];

export default async function supportEventLogger(input, emit, eventType) {
  console.log(eventType);
}

  --- End of index.js ---

  File: playground/src/workflows/policy-approval/components/policy-approval-logger/ui.jsx
  --- Start of ui.jsx ---
import React from 'react';

export default function supportEventLoggerNode({ data }) {
  return (
    <div className="node-container">
      <p className="node-title">{data.label}</p>
      <p className="node-subtitle">Subscribes to: {data.subscribe.join(', ') || 'None'}</p>
      <p className="node-subtitle">Some Text</p>
    </div>
  );
}
  --- End of ui.jsx ---

  File: playground/src/workflows/policy-approval/components/policy-fixer/index.js
  --- Start of index.js ---
// playground/src/workflows/policy-approval/components/policy-fixer/index.js
import { runChatCompletion } from "../../../../traffic/outbound/openai-api.js";
import { updateDocument } from "../../../../traffic/outbound/google-docs-api.js";

export const subscribe = ["doc.needs_approval"];

export default async function policyFixerHandler(input, emit) {
  const { fileId } = input;

  const response = await runChatCompletion([
    {
      role: "system",
      content: `You are helping fix policy documents to ensure compliance with company rules.
                Follow these guidelines:
                - Keep the same general structure and intent
                - Fix any compliance issues mentioned in recommendations
                - Update language to be clear and compliant
                - Remove any problematic sections
                - Only output the revised policy text`,
    },
    {
      role: "user",
      content: `Update this policy document to be compliant: [Your document content will be here]`,
    },
  ]);

  const updatedContent = response.choices[0].message.content.trim();

  // Update the document by appending the suggested policy
  const requests = [
    {
      insertText: {
        text: "\n\nSuggested Policy:\n" + updatedContent,
        location: {
          index: 1, // This will add it near the start of the document
        },
      },
    },
  ];

  await updateDocument(fileId, requests);

  emit({
    type: "doc.updated",
    data: {
      fileId,
      status: "suggested_update_added",
    },
  });
}

  --- End of index.js ---

  File: playground/src/workflows/policy-approval/components/policy-fixer/ui.jsx
  --- Start of ui.jsx ---
import React from 'react';

export default function PolicyFixerNode({ data }) {
  return (
    <div className="node-container">
      <p className="node-title">{data.label || "Policy Fixer"}</p>
      <p className="node-subtitle">Subscribes to: {data.subscribe?.join(', ') || 'None'}</p>
      <p className="node-subtitle">Automatically generates suggested policy updates</p>
    </div>
  );
}
  --- End of ui.jsx ---

  File: playground/src/workflows/policy-approval/components/rules-requester/index.js
  --- Start of index.js ---
export const subscribe = ["doc.content_fetched"];

const rulesRequester = async (input, emit) => {
  const { docContent, originalFileId } = input;
  const rulesFileId = process.env.POLICY_RULES_FILE_ID || "YOUR_RULES_FILE_ID";

  emit({
    type: "doc.fetch_requested",
    data: {
      fileId: rulesFileId,
      originalFileId,
      originalDocContent: docContent,
      targetEvent: "doc.ready_for_classification",
    },
  });
};

export default rulesRequester;

  --- End of index.js ---

  File: playground/src/workflows/policy-approval/components/rules-requester/ui.jsx
  --- Start of ui.jsx ---
import React from 'react';

export default function rulesRequesterrNode({ data }) {
  return (
    <div className="node-container">
      <p className="node-title">{data.label}</p>
      <p className="node-subtitle">Subscribes to: {data.subscribe.join(', ') || 'None'}</p>
      <p className="node-subtitle">Some Text</p>
    </div>
  );
}
  --- End of ui.jsx ---

  File: playground/src/workflows/policy-approval/config.js
  --- Start of config.js ---
export const config = {
  name: "policy-approval",
  description:
    "Approves policy documents based on compliance with Policy Rules.",
};

  --- End of config.js ---

  File: playground/src/workflows/policy-approval/doc-scheduler.js
  --- Start of doc-scheduler.js ---
export default {
  interval: "1h",
  eventType: "doc.escalate",
};

  --- End of doc-scheduler.js ---

  File: playground/src/workflows/policy-approval/example-docs/Policy-Rules.docx
  --- Start of Policy-Rules.docx ---

  --- End of Policy-Rules.docx ---

  File: playground/src/workflows/policy-approval/example-docs/q4-travel-policy-update.docx
  --- Start of q4-travel-policy-update.docx ---
Q4 Travel Policy Update
In order to streamline travel expenses and reduce administrative overhead, the following changes are proposed effective immediately:
Expense Threshold Increase:
The reimbursement threshold for travel-related expenses is increased from $500 to $800. This is considered an urgent update to ensure smooth year-end operations.
New Expense Category - Executive Meals:
A new expense category called “Executive Meals” is introduced. This category does not require employees to keep receipts for meal expenses under $50.
Compliance Adjustments:
While previous policies referenced PCI-DSS standards for vendor bookings, this update removes the explicit PCI-DSS clause, replacing it with a simplified internal compliance statement. Employees are assumed compliant without additional documentation.
Operational Urgency:
All changes should be adopted immediately. It’s not necessary to follow the old approval chains for these updates, as they are minor clarifications.
Summary:
These updates aim to reduce administrative burden and speed up approval times. Employees should enjoy greater flexibility in travel expenses without the previous constraints.


  --- End of q4-travel-policy-update.docx ---

  File: playground/src/workflows/policy-approval/test-drive-connection.js
  --- Start of test-drive-connection.js ---
import "dotenv/config";
import { google } from "googleapis";

const credentials = JSON.parse(process.env.GOOGLE_CREDENTIALS); // ensure this is set
const auth = new google.auth.GoogleAuth({
  credentials,
  scopes: ["https://www.googleapis.com/auth/drive.readonly"],
});
const client = await auth.getClient();
const drive = google.drive({ version: "v3", auth: client });

const res = await drive.files.export({
  fileId: "1dv_MRAIx7gicAsfGGhrYgIM_nWlZBBl3h6REA-wNlQI",
  mimeType: "text/plain",
});
console.log(res.data);

  --- End of test-drive-connection.js ---

  File: playground/src/workflows/policy-approval/test-openai-connection.js
  --- Start of test-openai-connection.js ---
import "dotenv/config";
import OpenAI from "openai";

const client = new OpenAI({
  apiKey: process.env["OPENAI_API_KEY"], // This is the default and can be omitted
});

async function main() {
  const chatCompletion = await client.chat.completions.create({
    messages: [{ role: "user", content: "Say this is a test" }],
    model: "gpt-4", // or 'gpt-3.5-turbo'
  });
  console.log(chatCompletion);
}

main();

  --- End of test-openai-connection.js ---

  File: playground/src/workflows/policy-approval/version.json
  --- Start of version.json ---
{
  "version": "0.1.0",
  "lastTested": "2024-12-16T00:00:00Z",
  "metrics": {}
}

  --- End of version.json ---

  File: playground/vite.config.js
  --- Start of vite.config.js ---
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";

export default defineConfig({
  server: {
    proxy: {
      "/api": "http://localhost:3000",
    },
    hmr: {
      protocol: "ws",
      clientPort: 5173,
    },
  },
  plugins: [react()],
  resolve: {
    alias: {
      motia: path.resolve(__dirname, "../packages/motia/src"),
    },
  },
  optimizeDeps: {
    include: ["react", "react-dom", "motia/ui"],
    force: true,
  },
  build: {
    commonjsOptions: {
      include: [/motia/, /node_modules/],
    },
  },
});

  --- End of vite.config.js ---

  File: pnpm-workspace.yaml
  --- Start of pnpm-workspace.yaml ---
packages:
  - "packages/*"
  - "playground"

  --- End of pnpm-workspace.yaml ---

  File: vite.config.js
  --- Start of vite.config.js ---
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";

export default defineConfig({
  root: path.resolve(__dirname, "src/ui"),
  plugins: [react()],
  server: {
    port: 5173,
    proxy: {
      "/api": "http://localhost:3000", // Proxy API calls to Node server
    },
  },
});

  --- End of vite.config.js ---

