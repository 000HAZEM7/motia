### FULL REPOSITORY CONTEXT START ###
--- BEGIN FILE: .gitignore ---
# Dependencies
node_modules/
.pnpm-store/
.npm
package-lock.json
yarn.lock
pnpm-lock.yaml
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz

# Ingore my scripts that I run
bs.sh

# Environment and secrets
.env
.env.*
!.env.example

# Builds and outputs
**/dist
dist/
build/
out/
.next/
.nuxt/
.output/
.vite/
.turbo

# Testing and coverage
coverage/
.nyc_output/

# IDEs and editors
.idea/
.vscode/
*.sublime-project
*.sublime-workspace
.project
.settings/
*.swp
*.swo

# OS generated
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs and debugging
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
.pnpm-debug.log*

# Cache and temp files
.cache/
.temp/
.tmp/
.eslintcache
.stylelintcache
tsconfig.tsbuildinfo--- END FILE: .gitignore ---
--- BEGIN FILE: README.md ---
# Motia.js Framework Repository

## Overview

This repository is dedicated to developing, refining, and testing the **Motia.js** framework. Motia.js is designed to simplify the creation of event-driven business automation workflows. The ultimate goal is to publish **Motia.js** as a standalone npm package, while the `src` directory serves as a sandbox for experimentation and implementation of real-world workflows.

### Aspirational Vision for Motia.js

Motia.js is a framework for building event-driven business automations that start simple but scale gracefully into production-grade systems. At its core, Motia.js helps define workflows as collections of small, testable components reacting to well-defined events. It:

- **Simplifies Workflow Design**: Quickly spin up logic, integrate external triggers, and schedule time-based tasks.
- **Encourages Maintainability**: Encourages incremental improvements and ensures high quality through testing and validation.
- **Scales**: Designed to grow from prototypes to enterprise-ready solutions.

## Repository Structure

### 1. **`motia.js`**

The heart of the repository, this file contains the core framework logic, including:

- **Event Bus**: Facilitates event-driven communication between components.
- **MotiaCore**: Central orchestrator that manages workflows, components, and events.
- **MotiaServer**: Integrates HTTP endpoints with the event-driven system.
- **VersionControl**: Tracks workflow versions and metrics.

The goal of this repo is to refine this framework iteratively and eventually publish it as a package.

### 2. **`src`**

This directory implements and tests the functionality of `motia.js` through real-world use cases. It serves as both a sandbox and a validation environment.

#### Key Subdirectories:

- **`workflows`**: Contains example workflows demonstrating how to use the Motia.js framework.
- **`traffic`**: HTTP traffic definitions used by `MotiaServer`.
- **`components`**: Modular pieces of workflows, each reacting to specific events.
- **`test-*` Scripts**: Scripts to validate external integrations, such as Google Drive and OpenAI connections.

### 3. **`package.json`**

Defines the npm scripts and dependencies required for the repository. Key scripts include:

- **`npm start`**: Initializes `MotiaCore`, `MotiaServer`, and `MotiaScheduler`.

### 4. **Utility Scripts**

- **`simulate-webhook.sh`**: Sends a mock webhook to simulate document uploads.
- **`test-drive-connection.js`**: Validates integration with Google Drive.
- **`test-openai-connection.js`**: Tests connectivity and functionality with OpenAI's GPT API.

### Flow Overview:

1. **Document Upload**: A webhook triggers a `doc.uploaded` event.
2. **Fetch Content**: Document content is retrieved from Google Drive.
3. **Request Rules**: Compliance rules are fetched.
4. **Classify Document**: OpenAI GPT evaluates compliance and suggests changes if needed.
5. **Approval/Escalation**: Based on classification, the document is approved or escalated.
6. **Logging**: All events are logged for debugging.

## Key Concepts in Motia.js

- **Event-Driven Architecture**: Events trigger component actions, creating loosely coupled workflows.
- **Dynamic Loading**: Workflows, traffic, and schedules are loaded dynamically at runtime.
- **External Integrations**: Works seamlessly with APIs like Google Drive and OpenAI.
- **Versioning**: Ensures workflows are incrementally improved and versioned.

## Goals for the Repository

1. Refine `motia.js` to meet production standards.
2. Test and validate the framework through example workflows in `src`.
3. Publish `motia.js` as an npm package with comprehensive documentation and examples.

## Setup Instructions

1. Clone the repository:

   ```bash
   git clone <repository_url>
   cd <repository_name>
   ```

2. Install dependencies:

   ```bash
   npm install
   ```

3. Set up environment variables:

   - `GOOGLE_CREDENTIALS`: JSON credentials for Google Drive API.
   - `OPENAI_API_KEY`: API key for OpenAI.
   - `POLICY_RULES_FILE_ID`: File ID of compliance rules on Google Drive.

4. Start the application:
   ```bash
   npm start
   ```

## Future Improvements

- Expand testing coverage for all components and workflows.
- Enhance scheduler to support cron expressions.
- Improve error handling and logging mechanisms.
- Add detailed documentation and examples for the npm package release.

## License

This project is licensed under [LICENSE_NAME].

---

This repository is a living document of the journey toward building and perfecting Motia.js. Feel free to explore, experiment, and contribute to its evolution!
--- END FILE: README.md ---
--- BEGIN FILE: package.json ---
{
  "name": "motia-monorepo",
  "private": true,
  "scripts": {
    "dev": "pnpm run -r --parallel dev",
    "build": "pnpm run -r build",
    "test": "pnpm run -r test",
    "flat": "node ./unrelated-tools/output-flat-repo.js",
    "drive-upload-hook": "./unrelated-tools/bin/drive-upload-hook.sh",
    "motia": "node packages/motia/src/cli/index.js"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.3.4",
    "concurrently": "^8.0.0",
    "dotenv": "^16.4.7",
    "ignore": "^6.0.2",
    "nodemon": "^3.0.0",
    "vite": "^6.0.0"
  },
  "packageManager": "pnpm@9.15.0+sha512.76e2379760a4328ec4415815bcd6628dee727af3779aaa4c914e3944156c4299921a89f976381ee107d41f12cfa4b66681ca9c718f0668fa0831ed4c6d8ba56c"
}
--- END FILE: package.json ---
--- BEGIN FILE: packages/motia/esbuild.config.js ---
// packages/motia/esbuild.config.js
import * as esbuild from "esbuild";

const ctx = await esbuild.context({
  entryPoints: ["src/core/index.js"],
  bundle: true,
  platform: "node",
  format: "esm",
  outdir: "dist/node",
  external: [
    // Node.js built-ins
    "path",
    "fs",
    "url",
    "querystring",
    "http",
    "https",
    "stream",
    "zlib",
    "events",
    "crypto",
    "util",
    "buffer",
    "string_decoder",
    "async_hooks",
    // External dependencies
    "express",
    "body-parser",
    "react",
    "react-dom",
    "reactflow",
  ],
  sourcemap: true,
});

if (process.argv.includes("--watch")) {
  await ctx.watch();
} else {
  await ctx.rebuild();
  await ctx.dispose();
}
--- END FILE: packages/motia/esbuild.config.js ---
--- BEGIN FILE: packages/motia/package.json ---
{
  "name": "motia",
  "version": "0.1.0",
  "type": "module",
  "exports": {
    ".": {
      "import": "./src/index.js",
      "require": "./dist/node/index.js"
    },
    "./ui": {
      "import": "./src/ui/index.js",
      "require": "./dist/browser/ui.js"
    }
  },
  "sideEffects": [
    "./src/ui/*"
  ],
  "files": [
    "dist",
    "src"
  ],
  "scripts": {
    "dev": "concurrently \"node esbuild.config.js --watch\" \"vite build --watch\"",
    "build": "node esbuild.config.js && vite build"
  },
  "devDependencies": {
    "esbuild": "^0.24.0"
  },
  "dependencies": {
    "body-parser": "^1.20.3",
    "express": "^4.21.2"
  }
}
--- END FILE: packages/motia/package.json ---
--- BEGIN FILE: packages/motia/src/cli/commands/createComponent.js ---
// packages/motia/src/cli/commands/createComponent.js
import fs from "fs";
import path from "path";
import { createIndexJs, createUiJsx } from "../templates.js";

export async function createComponent(workflowName, componentName) {
  if (!workflowName || !componentName) {
    throw new Error(
      "Usage: npx motia-cli create component <workflowName> <componentName>"
    );
  }

  const componentDir = path.join(
    process.cwd(),
    "playground", // Add playground to the path
    "src",
    "workflows",
    workflowName,
    "components",
    componentName
  );

  if (fs.existsSync(componentDir)) {
    throw new Error(`Component directory already exists: ${componentDir}`);
  }

  await fs.promises.mkdir(componentDir, { recursive: true });

  const indexJsPath = path.join(componentDir, "index.js");
  const uiJsxPath = path.join(componentDir, "ui.jsx");

  await fs.promises.writeFile(
    indexJsPath,
    createIndexJs(componentName),
    "utf8"
  );
  await fs.promises.writeFile(uiJsxPath, createUiJsx(componentName), "utf8");

  return componentDir;
}
--- END FILE: packages/motia/src/cli/commands/createComponent.js ---
--- BEGIN FILE: packages/motia/src/cli/index.js ---
#!/usr/bin/env node
import { createComponent } from "./commands/createComponent.js";

async function main() {
  const args = process.argv.slice(2);
  const command = args[0];

  if (command === "create" && args[1] === "component") {
    const workflowName = args[2];
    const componentName = args[3];

    try {
      const componentDir = await createComponent(workflowName, componentName);
    } catch (err) {
      console.error("Error:", err.message);
      process.exit(1);
    }
  } else {
    console.error(
      "Unknown command. Usage: npx motia-cli create component <workflowName> <componentName>"
    );
    process.exit(1);
  }
}

main().catch((err) => {
  console.error("Error:", err);
  process.exit(1);
});
--- END FILE: packages/motia/src/cli/index.js ---
--- BEGIN FILE: packages/motia/src/cli/templates.js ---
// packages/motia/src/cli/templates.js
import { toCamelCase, toPascalCase } from "./utils.js";

export function createIndexJs(componentName) {
  const safeHandlerName = toCamelCase(componentName) + "Handler";

  return `// index.js boilerplate
export const subscribe = ["example.my-event"];

export default async function ${safeHandlerName}(input, emit, eventType) {
  // Add your logic here
  console.log("Received event:", eventType, input);
}
`;
}

export function createUiJsx(componentName) {
  const safeComponentName = toPascalCase(componentName) + "Node";

  return `// ui.jsx boilerplate
import React from 'react';

export default function ${safeComponentName}({ data }) {
  return (
    <div className="node-container">
      <p className="node-title">{data.label || "${toPascalCase(
        componentName
      )}"}</p>
      <p className="node-subtitle">Subscribes to: {data.subscribe?.join(", ")}</p>
    </div>
  );
}
`;
}
--- END FILE: packages/motia/src/cli/templates.js ---
--- BEGIN FILE: packages/motia/src/cli/utils.js ---
export function toCamelCase(str) {
  return str.replace(/-([a-z])/g, (_, char) => char.toUpperCase());
}

export function toPascalCase(str) {
  const camel = toCamelCase(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}
--- END FILE: packages/motia/src/cli/utils.js ---
--- BEGIN FILE: packages/motia/src/core/MessageBus.js ---
/**
 * In-Memory Message Bus Implementation
 * ------------------------------------
 * The InMemoryMessageBus provides a simple, local-only event bus for the Motia framework.
 * It manages event subscribers and publishes events to them. This bus operates fully in-memory,
 * making it ideal for development, testing, and lightweight deployments.
 *
 * Key Responsibilities:
 * - Store a list of subscribers (event handlers)
 * - When an event is published, deliver it to all subscribers that match the event type
 * - Handle errors in subscriber callbacks gracefully
 *
 * This class does not persist events or maintain any external state,
 * and is not suitable for production scenarios that require durability or scaling.
 */
export class InMemoryMessageBus {
  constructor() {
    this.subscribers = [];
  }

  async publish(event, options) {
    await Promise.all(
      this.subscribers.map((subscriber) =>
        subscriber(event, options).catch((error) => {
          console.error("Error in subscriber:", error);
        })
      )
    );
  }

  subscribe(handler) {
    this.subscribers.push(handler);
  }
}
--- END FILE: packages/motia/src/core/MessageBus.js ---
--- BEGIN FILE: packages/motia/src/core/MotiaCore.js ---
import { fileURLToPath, pathToFileURL } from "url";
import path from "path";
import fs from "fs";
import { InMemoryMessageBus } from "./MessageBus.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Core Orchestrator: MotiaCore
 * ----------------------------
 * MotiaCore serves as the central orchestrator of the Motia framework. It manages the lifecycle
 * of workflows, components, and the event bus, acting as the heart of the entire system.
 *
 * Key Responsibilities:
 * - Initialize and configure the message bus (either in-memory or a provided one)
 * - Load and register workflows and their associated components
 * - Emit events into the system and deliver them to subscribed components
 *
 * MotiaCore provides the foundational logic that ties together components, events,
 * and workflows, enabling flexible, event-driven behavior throughout the application.
 */
export class MotiaCore {
  constructor() {
    this.messageBus = new InMemoryMessageBus();
    this.workflows = new Map();
    this.components = new Map();
  }

  describeWorkflows() {
    return {
      workflows: Array.from(this.workflows.keys()).map((workflowPath) => {
        const workflowName = path.basename(workflowPath);
        const componentEntries = Array.from(this.components.entries()).filter(
          ([compPath]) => compPath.includes(workflowName)
        );

        return {
          name: workflowName,
          components: componentEntries.map(([compPath, compModule]) => {
            const compDirName = path.basename(path.dirname(compPath));
            return {
              id: compDirName,
              subscribe: compModule.subscribe || [],
              emits: compModule.emits || [],
            };
          }),
        };
      }),
    };
  }

  async registerWorkflow(workflowPath) {
    try {
      const configPath = path.resolve(workflowPath, "config.js");
      const configModule = await import(pathToFileURL(configPath).href);
      this.workflows.set(workflowPath, configModule);
    } catch (error) {
      console.error(`Error registering workflow at ${workflowPath}:`, error);
    }
  }

  async registerComponent(componentPath) {
    try {
      const componentModule = await import(pathToFileURL(componentPath).href);
      if (componentModule.subscribe) {
        // Store an object that includes the handler, subscribe, and emits arrays
        this.components.set(componentPath, {
          handler: componentModule.default,
          subscribe: componentModule.subscribe || [],
          emits: componentModule.emits || [],
        });
      }
    } catch (error) {
      console.error(`Error registering component at ${componentPath}:`, error);
    }
  }

  async emit(event, options) {
    await this.messageBus.publish(event, options);
  }

  async initialize(options = {}) {
    const workflowPaths = options.workflowPaths || ["./src/workflows"];
    this.messageBus = options.messageBus || new InMemoryMessageBus();

    this.workflows = new Map();
    this.components = new Map();

    // Convert workflowPaths to absolute
    const absoluteWorkflowPaths = workflowPaths.map((p) => path.resolve(p));

    // Load all workflows
    for (const wPath of absoluteWorkflowPaths) {
      const workflowFiles = await this.findWorkflowFiles(wPath);
      for (const file of workflowFiles) {
        await this.registerWorkflow(file);
      }
    }

    // Load all components from these workflows
    const componentFiles = await this.findComponentFiles(absoluteWorkflowPaths);
    for (const file of componentFiles) {
      await this.registerComponent(file);
    }

    // Subscribe components to message bus
    for (const [id, componentInfo] of this.components.entries()) {
      for (const eventPattern of componentInfo.subscribe) {
        this.messageBus.subscribe(async (event, opts) => {
          if (this.eventMatchesPattern(event.type, eventPattern)) {
            await componentInfo.handler(
              event.data,
              (e) => this.emit(e, opts),
              event.type
            );
          }
        });
      }
    }
  }

  async findWorkflowFiles(basePath) {
    const workflows = [];
    try {
      const entries = await fs.promises.readdir(basePath, {
        withFileTypes: true,
      });
      for (const entry of entries) {
        if (entry.isDirectory()) {
          const workflowPath = path.join(basePath, entry.name);
          const files = await fs.promises.readdir(workflowPath);
          if (files.includes("config.js") && files.includes("version.json")) {
            // Return absolute path
            workflows.push(path.resolve(workflowPath));
          }
        }
      }
    } catch (error) {
      console.error("Error finding workflow files:", error);
    }
    return workflows;
  }

  async findComponentFiles(paths) {
    const components = [];
    for (const basePath of paths) {
      try {
        const workflowDirs = await fs.promises.readdir(basePath, {
          withFileTypes: true,
        });

        for (const workflowDir of workflowDirs) {
          if (!workflowDir.isDirectory()) continue;

          const componentsPath = path.join(
            basePath,
            workflowDir.name,
            "components"
          );
          try {
            await this.searchComponents(componentsPath, components);
          } catch {
            // If components dir doesn't exist, skip
          }
        }
      } catch (error) {
        console.error("Error finding component files:", error);
      }
    }
    return components.map((c) => path.resolve(c));
  }

  async searchComponents(dir, components) {
    let entries;
    try {
      entries = await fs.promises.readdir(dir, { withFileTypes: true });
    } catch {
      return;
    }

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        await this.searchComponents(fullPath, components);
      } else if (
        entry.name.endsWith(".js") &&
        !entry.name.endsWith(".test.js")
      ) {
        if (entry.name.endsWith(".js") && !entry.name.endsWith(".test.js")) {
          components.push(fullPath);
        }
      }
    }
  }

  eventMatchesPattern(eventType, pattern) {
    if (pattern === "*") return true;
    if (pattern === eventType) return true;
    if (pattern.endsWith(".*")) {
      const prefix = pattern.slice(0, -2);
      return eventType.startsWith(prefix);
    }
    return false;
  }
}
--- END FILE: packages/motia/src/core/MotiaCore.js ---
--- BEGIN FILE: packages/motia/src/core/MotiaServer.js ---
import express from "express";
import bodyParser from "body-parser";
import fs from "fs";
import path from "path";
import { fileURLToPath, pathToFileURL } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class MotiaServer {
  constructor() {
    this.traffic = new Map();
    this.express = express();
    this.express.use(bodyParser.json());
  }

  async findTrafficFiles(paths) {
    const trafficFiles = [];

    const searchTraffic = async (dir) => {
      let entries;
      try {
        entries = await fs.promises.readdir(dir, { withFileTypes: true });
      } catch {
        return;
      }

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
          await searchTraffic(fullPath);
        } else if (
          entry.name.endsWith(".js") &&
          !entry.name.endsWith(".test.js")
        ) {
          trafficFiles.push(fullPath);
        }
      }
    };

    for (const basePath of paths) {
      const absolutePath = path.resolve(basePath);
      await searchTraffic(absolutePath);
    }
    return trafficFiles;
  }

  async initialize(core, trafficPaths = ["./traffic/inbound"]) {
    this.core = core;
    const trafficFiles = await this.findTrafficFiles(trafficPaths);

    for (const trafficFile of trafficFiles) {
      const trafficModule = await import(pathToFileURL(trafficFile));
      const trafficConfigs = Array.isArray(trafficModule.default)
        ? trafficModule.default
        : [trafficModule.default];

      for (const config of trafficConfigs) {
        this.registerTraffic(config);
      }
    }

    // Register routes for each traffic config
    this.traffic.forEach((config, routePath) => {
      this.express[config.method.toLowerCase()](routePath, async (req, res) => {
        try {
          await this.handleRequest(req, res);
        } catch (error) {
          res.status(500).json({ error: error.message });
        }
      });
    });

    // Serve static files
    this.express.use(express.static(path.join(__dirname, "../dist")));

    // Return workflow descriptions
    this.express.get("/api/workflows", (req, res) => {
      res.json(this.core.describeWorkflows());
    });

    // Catch-all route to serve index.html
    this.express.get("*", (req, res) => {
      res.sendFile(path.join(__dirname, "../dist/index.html"));
    });

    const port = process.env.PORT || 3000;
    this.express.listen(port, () => {
      console.log(`Server listening on port ${port}`);
    });
  }

  async handleRequest(req, res) {
    const traffic = this.traffic.get(req.path);
    if (!traffic) {
      res.status(404).json({ error: "Traffic not found" });
      return;
    }

    try {
      if (traffic.authorize) {
        await traffic.authorize(req);
      }

      const event = await traffic.transform(req);

      await this.core.emit(event, {
        traceId: req.headers["x-trace-id"],
        metadata: {
          source: "http",
          path: req.path,
          method: req.method,
        },
      });

      res.status(200).json({ success: true, eventType: event.type });
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }

  registerTraffic(config) {
    if (!config.path || !config.method || !config.transform) {
      throw new Error("Invalid traffic configuration");
    }

    const routePath = config.path.startsWith("/")
      ? config.path
      : `/${config.path}`;
    this.traffic.set(routePath, config);
  }
}
--- END FILE: packages/motia/src/core/MotiaServer.js ---
--- BEGIN FILE: packages/motia/src/core/index.js ---
export * from "./MessageBus.js";
export * from "./MotiaCore.js";
export * from "./MotiaServer.js";

// Also export the utility functions if they're needed externally
export function defineTraffic(config) {
  return config;
}

export function defineRoute(config) {
  return config;
}
--- END FILE: packages/motia/src/core/index.js ---
--- BEGIN FILE: packages/motia/src/index.js ---
// Core functionality
export * from "./core/MotiaCore.js";
export * from "./core/MotiaServer.js";
export * from "./core/MessageBus.js";

// Helper functions
export { defineTraffic, defineRoute } from "./core/index.js";

// Note: UI components are exported separately via './ui' entry point
// CLI is accessed via the bin entry point
--- END FILE: packages/motia/src/index.js ---
--- BEGIN FILE: packages/motia/src/ui/MotiaUi.js ---
export class MotiaUi {
  static nodeTypes = {};

  static registerNodeTypesFromGlob(modules) {
    const nodeTypes = {};
    for (const path in modules) {
      const match = path.match(/components\/([^/]+)\/ui\.jsx$/);
      if (match) {
        const componentId = match[1];
        nodeTypes[componentId] = modules[path].default;
      }
    }
    MotiaUi.nodeTypes = { ...MotiaUi.nodeTypes, ...nodeTypes };
  }

  static getNodeTypes() {
    return MotiaUi.nodeTypes;
  }
}
--- END FILE: packages/motia/src/ui/MotiaUi.js ---
--- BEGIN FILE: packages/motia/src/ui/hooks/useMotiaFlow.js ---
import { useEffect, useState } from "react";

export function useMotiaFlow() {
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function loadWorkflows() {
      try {
        const res = await fetch("/api/workflows");
        if (!res.ok) {
          throw new Error(`Failed to fetch workflows: ${res.statusText}`);
        }
        const data = await res.json();
        const workflow = data.workflows?.[0];

        if (!workflow) {
          throw new Error("No workflows found");
        }

        const rawNodes = workflow.components.map((comp, idx) => ({
          id: comp.id,
          type: comp.id,
          position: { x: idx * 200, y: 100 * (idx % 2 === 0 ? 1 : 2) },
          data: {
            label: comp.id,
            subscribe: comp.subscribe || [],
            emits: comp.emits || [],
          },
        }));

        // Map: event -> list of node IDs that subscribe to it
        const subscribersMap = {};
        rawNodes.forEach((node) => {
          (node.data.subscribe || []).forEach((evt) => {
            if (!subscribersMap[evt]) subscribersMap[evt] = [];
            subscribersMap[evt].push(node.id);
          });
        });

        const rawEdges = [];
        rawNodes.forEach((node) => {
          (node.data.emits || []).forEach((emittedEvent) => {
            const subscribers = subscribersMap[emittedEvent] || [];
            subscribers.forEach((subNodeId) => {
              if (subNodeId !== node.id) {
                rawEdges.push({
                  id: `${node.id}-${subNodeId}-${emittedEvent}`,
                  source: node.id,
                  target: subNodeId,
                });
              }
            });
          });
        });

        setNodes(rawNodes);
        setEdges(rawEdges);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }

    loadWorkflows();
  }, []);

  return { nodes, edges, loading, error };
}
--- END FILE: packages/motia/src/ui/hooks/useMotiaFlow.js ---
--- BEGIN FILE: packages/motia/src/ui/index.js ---
// packages/motia/src/ui/index.js
import { MotiaUi } from "./MotiaUi.js";
import { useMotiaFlow } from "./hooks/useMotiaFlow.js";

// Export as named exports
export { MotiaUi, useMotiaFlow };

// Also provide a default export if needed
export default {
  MotiaUi,
  useMotiaFlow,
};
--- END FILE: packages/motia/src/ui/index.js ---
--- BEGIN FILE: packages/motia/src/ui/styles.css ---
.node-container {
    padding: 12px 16px;
    border-radius: 8px;
    background-color: #1e1e1e;
    color: #ddd;
    border: 1px solid #333;
    font-family: 'Inter', sans-serif;
    font-size: 14px;
  }
  
  .node-title {
    font-size: 16px;
    font-weight: 600;
    margin: 0 0 8px 0;
  }
  
  .node-subtitle {
    margin: 0;
    font-size: 13px;
    color: #555;
  }
  
  .react-flow__controls {
    background-color: #2c2c2c;
    color: #fff;
  }--- END FILE: packages/motia/src/ui/styles.css ---
--- BEGIN FILE: packages/motia/vite.config.js ---
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  build: {
    lib: {
      entry: "src/ui/index.js",
      formats: ["es"],
      fileName: "ui",
    },
    outDir: "dist/browser",
    rollupOptions: {
      external: ["react", "react-dom", "reactflow"],
    },
  },
  plugins: [react()],
});
--- END FILE: packages/motia/vite.config.js ---
--- BEGIN FILE: playground/.env.example ---
GOOGLE_CREDENTIALS=""
OPENAI_API_KEY=""
POLICY_RULES_FILE_ID=""--- END FILE: playground/.env.example ---
--- BEGIN FILE: playground/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Motia UI</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" />
</head>
<body>
  <div id="root"></div>
  <script type="module" src="/src/ui/index.jsx"></script>
</body>
</html>--- END FILE: playground/index.html ---
--- BEGIN FILE: playground/package.json ---
{
  "name": "motia-playground",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "concurrently \"nodemon -w ../motia/dist -w src src/index.js\" \"vite\"",
    "build": "vite build"
  },
  "dependencies": {
    "dagre": "^0.8.5",
    "dotenv": "^16.4.7",
    "googleapis": "^144.0.0",
    "motia": "workspace:*",
    "openai": "^4.76.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "reactflow": "^11.11.4"
  }
}
--- END FILE: playground/package.json ---
--- BEGIN FILE: playground/src/index.js ---
import "dotenv/config";
import path from "path";
import { fileURLToPath } from "url";
import { MotiaCore, MotiaServer } from "motia";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function main() {
  const core = new MotiaCore();
  const server = new MotiaServer();

  console.log("Initializing Motia...");

  // Initialize with correct workflow paths
  await core.initialize({
    workflowPaths: [path.join(__dirname, "workflows")],
  });

  // Initialize server with correct traffic paths - note the src/traffic/inbound path
  await server.initialize(core, [path.join(__dirname, "traffic/inbound")]);

  scheduler.start();

  console.log("Workflow initialized. Listening for events...");
}

main().catch(console.error);
--- END FILE: playground/src/index.js ---
--- BEGIN FILE: playground/src/traffic/inbound/data-upload.js ---
// playground/src/traffic/inbound/data-upload.js
import { defineTraffic } from "motia";

export default defineTraffic({
  path: "/api/data/upload",
  method: "POST",
  transform: (req) => {
    const { rawData } = req.body; // Expect an array of objects
    return { type: "data.uploaded", data: { rawData } };
  },
});
--- END FILE: playground/src/traffic/inbound/data-upload.js ---
--- BEGIN FILE: playground/src/traffic/outbound/google-docs-api.js ---
import { google } from "googleapis";

export async function updateDocument(fileId, requests) {
  const credentials = JSON.parse(process.env.GOOGLE_CREDENTIALS);
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: [
      "https://www.googleapis.com/auth/documents",
      "https://www.googleapis.com/auth/drive",
    ],
  });

  const docsClient = google.docs({
    version: "v1",
    auth: await auth.getClient(),
  });

  await docsClient.documents.batchUpdate({
    documentId: fileId,
    requestBody: { requests },
  });
}
--- END FILE: playground/src/traffic/outbound/google-docs-api.js ---
--- BEGIN FILE: playground/src/traffic/outbound/google-drive-api.js ---
import { google } from "googleapis";

export async function getDocContent(fileId) {
  const credentials = JSON.parse(process.env.GOOGLE_CREDENTIALS || "{}");
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/drive.readonly"],
  });
  const drive = google.drive({ version: "v3", auth: await auth.getClient() });

  const res = await drive.files.export(
    { fileId, mimeType: "text/plain" },
    { responseType: "text" }
  );

  return res.data;
}
--- END FILE: playground/src/traffic/outbound/google-drive-api.js ---
--- BEGIN FILE: playground/src/traffic/outbound/openai-api.js ---
import OpenAI from "openai";

const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

export async function runChatCompletion(messages, options = {}) {
  const response = await client.chat.completions.create({
    model: options.model || "gpt-3.5-turbo",
    messages,
    max_tokens: options.max_tokens || 600,
    temperature: options.temperature ?? 0,
  });

  return response;
}
--- END FILE: playground/src/traffic/outbound/openai-api.js ---
--- BEGIN FILE: playground/src/ui/App.jsx ---
import React, { useEffect, useState, useMemo } from 'react';
import ReactFlow, {
  Controls,
  Background,
  applyEdgeChanges,
  applyNodeChanges
} from 'reactflow';
import 'reactflow/dist/style.css';
import './styles.css';
import { MotiaUi, useMotiaFlow } from 'motia/ui';
import './motia-ui.js';
import EnhancedNode from './EnhancedNode.jsx';
import { layoutElements } from './utils/layout.js';

export default function EnhancedWorkflowUI() {
  const { nodes: initialNodes, edges: initialEdges, loading, error } = useMotiaFlow();
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);

  const nodeTypes = useMemo(() => {
    return { ...MotiaUi.getNodeTypes(), default: EnhancedNode };
  }, []);

  useEffect(() => {
    // If we have nodes and edges, run them through dagre layout
    if (initialNodes.length > 0 && initialEdges.length > 0) {
      const { nodes: layoutedNodes, edges: layoutedEdges } = layoutElements(initialNodes, initialEdges);
      setNodes(layoutedNodes);
      setEdges(layoutedEdges);
    } else {
      // If no nodes or edges yet, just set them directly (e.g., while loading)
      setNodes(initialNodes);
      setEdges(initialEdges);
    }
  }, [initialNodes, initialEdges]);

  if (loading) {
    return (
      <div style={{
        display: 'flex', alignItems: 'center', justifyContent: 'center',
        width: '100vw', height: '100vh', backgroundColor: '#111827', color: '#fff'
      }}>
        <div style={{ fontSize: '1.5rem' }}>Loading workflow...</div>
      </div>
    );
  }

  if (error) {
    return (
      <div style={{
        display: 'flex', alignItems: 'center', justifyContent: 'center',
        width: '100vw', height: '100vh', backgroundColor: '#111827', color: '#fff'
      }}>
        <div style={{ fontSize: '1.5rem', color: 'red' }}>Error: {error}</div>
      </div>
    );
  }

  return (
    <div style={{ width: '100vw', height: '100vh', backgroundColor: '#111827', position: 'relative' }}>
      <div style={{
        position: 'absolute', top: '1rem', left: '1rem', backgroundColor: '#1f2937',
        padding: '1rem', borderRadius: '8px', color: '#fff', zIndex: 10
      }}>
        <h1 style={{ fontSize: '1.25rem', fontWeight: 'bold', marginBottom: '0.5rem' }}>Workflow Visualization</h1>
        <p style={{ fontSize: '0.875rem', color: '#ccc' }}>Drag nodes to rearrange • Zoom to explore</p>
      </div>

      <ReactFlow
        nodes={nodes}
        edges={edges}
        nodeTypes={nodeTypes}
        onNodesChange={(changes) => setNodes((ns) => applyNodeChanges(changes, ns))}
        onEdgesChange={(changes) => setEdges((es) => applyEdgeChanges(changes, es))}
        fitView
        defaultEdgeOptions={{
          type: 'smoothstep',
          animated: true,
          style: { stroke: '#666', strokeWidth: 2 },
          markerEnd: { type: 'arrowclosed' },
        }}
        style={{ backgroundColor: '#111827' }}
      >
        <Background
          variant="dots"
          gap={20}
          size={1}
          color="#444"
          style={{ backgroundColor: '#111827' }}
        />
        <Controls style={{
          backgroundColor: '#333',
          borderRadius: '4px',
          color: '#fff'
        }}/>
      </ReactFlow>
    </div>
  );
}
--- END FILE: playground/src/ui/App.jsx ---
--- BEGIN FILE: playground/src/ui/EnhancedNode.jsx ---
import React from 'react';
import { Handle, Position } from 'reactflow';

export default function EnhancedNode({ data }) {
  const getNodeColor = (type) => {
    const colors = {
      generator: '#4f46e5',    // Indigo
      transformer: '#0891b2',  // Cyan
      logger: '#059669',       // Emerald
      default: '#6366f1'       // Violet
    };

    const lowerType = (type || '').toLowerCase();
    if (lowerType.includes('generator')) return colors.generator;
    if (lowerType.includes('transform')) return colors.transformer;
    if (lowerType.includes('logger')) return colors.logger;
    return colors.default;
  };

  const nodeColor = getNodeColor(data.label);

  const containerStyle = {
    position: 'relative',
    borderRadius: '8px',
    boxShadow: '0 1px 3px rgba(0,0,0,0.2)',
    border: '1px solid #444',
    backgroundColor: '#2c2c2c',
    padding: '12px 16px',
    minWidth: '200px',
    color: '#eee',
    borderLeft: `4px solid ${nodeColor}`,
    fontFamily: 'Arial, sans-serif',
    fontSize: '14px'
  };

  const handleStyle = {
    width: '8px',
    height: '8px',
    backgroundColor: '#555',
    border: '2px solid #333',
    borderRadius: '50%'
  };

  const titleStyle = {
    fontSize: '16px',
    fontWeight: 'bold',
    marginBottom: '4px'
  };

  const subtitleStyle = {
    fontSize: '13px',
    color: '#ccc',
    margin: '2px 0'
  };

  const badgeStyle = {
    display: 'inline-block',
    padding: '2px 4px',
    borderRadius: '4px',
    backgroundColor: '#333',
    color: '#eee',
    fontSize: '12px',
    marginRight: '4px',
    marginBottom: '4px'
  };

  return (
    <div style={containerStyle}>
      <Handle type="target" position={Position.Top} style={handleStyle} />
      <Handle type="source" position={Position.Bottom} style={handleStyle} />

      <div style={{ marginBottom: '8px' }}>
        <h3 style={titleStyle}>{data.label}</h3>
        {data.subscribe?.length > 0 && (
          <div style={subtitleStyle}>
            <span style={{ fontWeight: '600' }}>Subscribes to:</span>
            <div style={{ marginTop: '4px' }}>
              {data.subscribe.map((event, idx) => (
                <span key={idx} style={badgeStyle}>{event}</span>
              ))}
            </div>
          </div>
        )}
        {data.emits?.length > 0 && (
          <div style={subtitleStyle}>
            <span style={{ fontWeight: '600' }}>Emits:</span>
            <div style={{ marginTop: '4px' }}>
              {data.emits.map((event, idx) => (
                <span key={idx} style={{ ...badgeStyle, backgroundColor: '#222' }}>{event}</span>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
--- END FILE: playground/src/ui/EnhancedNode.jsx ---
--- BEGIN FILE: playground/src/ui/index.jsx ---
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App.jsx';

const container = document.getElementById('root');
const root = createRoot(container);
root.render(<App />);--- END FILE: playground/src/ui/index.jsx ---
--- BEGIN FILE: playground/src/ui/motia-ui.js ---
// playground/src/ui/motia-ui.js
import { MotiaUi } from "motia/ui";

// Run glob in frontend environment
const modules = import.meta.glob("../workflows/**/components/**/ui.jsx", {
  eager: true,
});

MotiaUi.registerNodeTypesFromGlob(modules);

// Export for use in other files
export { MotiaUi };
--- END FILE: playground/src/ui/motia-ui.js ---
--- BEGIN FILE: playground/src/ui/styles.css ---
body, html {
  margin: 0;
  padding: 0;
  background-color: #121212;
  font-family: 'Inter', sans-serif;
  color: #eee;
  height: 100%;
  width: 100%;
}

.node-container {
  padding: 12px 16px;
  border-radius: 8px;
  background-color: #2c2c2c;
  color: #eee;
  border: 1px solid #444;
  font-size: 14px;
  max-width: 200px;
}

.node-title {
  font-size: 16px;
  font-weight: 700;
  margin: 0 0 4px 0;
}

.node-subtitle {
  margin: 0;
  font-size: 13px;
  color: #ccc;
}

.react-flow__controls {
  background-color: #333;
  color: #fff;
}

.node-container button {
  background: #444;
  color: #fff;
  border: none;
  padding: 6px 10px;
  cursor: pointer;
  margin-top: 8px;
  border-radius: 4px;
}

.node-container button:hover {
  background: #555;
}

/* Ensure nodes are draggable */
.react-flow__node {
  cursor: grab;
}

.react-flow__node.dragging {
  cursor: grabbing;
}

/* Reset any properties that might interfere with dragging */
.node-container {
  pointer-events: auto;
  user-select: none;
  position: relative;
}
--- END FILE: playground/src/ui/styles.css ---
--- BEGIN FILE: playground/src/ui/utils/layout.js ---
import dagre from 'dagre';

export function layoutElements(nodes, edges) {
  const dagreGraph = new dagre.graphlib.Graph();
  dagreGraph.setDefaultEdgeLabel(() => ({}));

  // Top-to-bottom layout
  dagreGraph.setGraph({ rankdir: 'TB', ranksep: 100, nodesep: 100 });

  // Assume each node ~200x50; adjust if needed
  nodes.forEach((node) => {
    dagreGraph.setNode(node.id, { width: 200, height: 50 });
  });

  edges.forEach((edge) => {
    dagreGraph.setEdge(edge.source, edge.target);
  });

  dagre.layout(dagreGraph);

  const layoutedNodes = nodes.map((node) => {
    const { x, y } = dagreGraph.node(node.id);
    return {
      ...node,
      position: {
        x: x - 100, // center based on width 200
        y: y - 25   // center based on height 50
      },
      draggable: false
    };
  });

  return { nodes: layoutedNodes, edges };
}
--- END FILE: playground/src/ui/utils/layout.js ---
--- BEGIN FILE: playground/src/workflows/data-processing/components/join-data/index.js ---
export const subscribe = ["data.transformed.partA", "data.transformed.partB"];
export const emits = ["data.joined"];

let partAData = null;
let partBData = null;

export default async function joinData(input, emit, eventType) {
  if (eventType === "data.transformed.partA") {
    partAData = input.transformedA;
  }
  if (eventType === "data.transformed.partB") {
    partBData = input.transformedB;
  }

  if (partAData && partBData) {
    const joinedData = [...partAData, ...partBData];
    await emit({ type: "data.joined", data: { joinedData } });
    partAData = null;
    partBData = null;
  }
}
--- END FILE: playground/src/workflows/data-processing/components/join-data/index.js ---
--- BEGIN FILE: playground/src/workflows/data-processing/components/join-data/ui.jsx ---
import React from 'react';
import { Handle, Position } from 'reactflow';

export default function JoinDataNode() {
  return (
    <div className="node-container">
      <Handle type="target" position={Position.Top} />
      <Handle type="source" position={Position.Bottom} />
      <p className="node-title">Join Data</p>
      <p className="node-subtitle">Subscribes: data.transformed.partA, data.transformed.partB</p>
      <p className="node-subtitle">Emits: data.joined</p>
    </div>
  );
}
--- END FILE: playground/src/workflows/data-processing/components/join-data/ui.jsx ---
--- BEGIN FILE: playground/src/workflows/data-processing/components/save-data/index.js ---
export const subscribe = ["data.joined"];
export const emits = ["data.saved"];

export default async function saveData(input, emit) {
  const { joinedData } = input;
  console.log("Saving data:", joinedData);
  await emit({ type: "data.saved", data: { count: joinedData.length, status: "success" } });
}
--- END FILE: playground/src/workflows/data-processing/components/save-data/index.js ---
--- BEGIN FILE: playground/src/workflows/data-processing/components/save-data/ui.jsx ---
import React from 'react';
import { Handle, Position } from 'reactflow';

export default function SaveDataNode() {
  return (
    <div className="node-container">
      <Handle type="target" position={Position.Top} />
      <p className="node-title">Save Data</p>
      <p className="node-subtitle">Subscribes: data.joined</p>
      <p className="node-subtitle">Emits: data.saved</p>
    </div>
  );
}
--- END FILE: playground/src/workflows/data-processing/components/save-data/ui.jsx ---
--- BEGIN FILE: playground/src/workflows/data-processing/components/split-data/index.js ---
export const subscribe = ["data.validated"];
export const emits = ["data.split.partA", "data.split.partB"];

export default async function splitData(input, emit) {
  const { rawData } = input;
  const mid = Math.floor(rawData.length / 2);
  const partA = rawData.slice(0, mid);
  const partB = rawData.slice(mid);

  await emit({ type: "data.split.partA", data: { partA } });
  await emit({ type: "data.split.partB", data: { partB } });
}
--- END FILE: playground/src/workflows/data-processing/components/split-data/index.js ---
--- BEGIN FILE: playground/src/workflows/data-processing/components/split-data/ui.jsx ---
import React from 'react';
import { Handle, Position } from 'reactflow';

export default function SplitDataNode() {
  return (
    <div className="node-container">
      <Handle type="target" position={Position.Top} />
      <Handle type="source" position={Position.Bottom} id="a" />
      <p className="node-title">Split Data</p>
      <p className="node-subtitle">Subscribes: data.validated</p>
      <p className="node-subtitle">Emits: data.split.partA, data.split.partB</p>
    </div>
  );
}
--- END FILE: playground/src/workflows/data-processing/components/split-data/ui.jsx ---
--- BEGIN FILE: playground/src/workflows/data-processing/components/transform-partA/index.js ---
export const subscribe = ["data.split.partA"];
export const emits = ["data.transformed.partA"];

export default async function transformPartA(input, emit) {
  const { partA } = input;
  const transformedA = partA.map(item => ({ ...item, transformed: true, part: 'A' }));
  await emit({ type: "data.transformed.partA", data: { transformedA } });
}
--- END FILE: playground/src/workflows/data-processing/components/transform-partA/index.js ---
--- BEGIN FILE: playground/src/workflows/data-processing/components/transform-partA/ui.jsx ---
import React from 'react';
import { Handle, Position } from 'reactflow';

export default function TransformPartANode() {
  return (
    <div className="node-container">
      <Handle type="target" position={Position.Top} />
      <Handle type="source" position={Position.Bottom} />
      <p className="node-title">Transform Part A</p>
      <p className="node-subtitle">Subscribes: data.split.partA</p>
      <p className="node-subtitle">Emits: data.transformed.partA</p>
    </div>
  );
}
--- END FILE: playground/src/workflows/data-processing/components/transform-partA/ui.jsx ---
--- BEGIN FILE: playground/src/workflows/data-processing/components/transform-partB/index.js ---
export const subscribe = ["data.split.partB"];
export const emits = ["data.transformed.partB"];

export default async function transformPartB(input, emit) {
  const { partB } = input;
  const transformedB = partB.map(item => ({ ...item, transformed: true, part: 'B' }));
  await emit({ type: "data.transformed.partB", data: { transformedB } });
}
--- END FILE: playground/src/workflows/data-processing/components/transform-partB/index.js ---
--- BEGIN FILE: playground/src/workflows/data-processing/components/transform-partB/ui.jsx ---
import React from 'react';
import { Handle, Position } from 'reactflow';

export default function TransformPartBNode() {
  return (
    <div className="node-container">
      <Handle type="target" position={Position.Top} />
      <Handle type="source" position={Position.Bottom} />
      <p className="node-title">Transform Part B</p>
      <p className="node-subtitle">Subscribes: data.split.partB</p>
      <p className="node-subtitle">Emits: data.transformed.partB</p>
    </div>
  );
}
--- END FILE: playground/src/workflows/data-processing/components/transform-partB/ui.jsx ---
--- BEGIN FILE: playground/src/workflows/data-processing/components/validate-data/index.js ---
export const subscribe = ["data.uploaded"];
export const emits = ["data.validated"];

export default async function validateData(input, emit) {
  const { rawData } = input;
  const isValid = Boolean(rawData && rawData.length > 0);

  if (isValid) {
    await emit({ type: "data.validated", data: { rawData } });
  } else {
    console.error("Data validation failed. No data emitted.");
  }
}
--- END FILE: playground/src/workflows/data-processing/components/validate-data/index.js ---
--- BEGIN FILE: playground/src/workflows/data-processing/components/validate-data/ui.jsx ---
import React from 'react';
import { Handle, Position } from 'reactflow';

export default function ValidateDataNode() {
  return (
    <div className="node-container">
      <Handle type="target" position={Position.Top} />
      <Handle type="source" position={Position.Bottom} />
      <p className="node-title">Validate Data</p>
      <p className="node-subtitle">Subscribes: data.uploaded</p>
      <p className="node-subtitle">Emits: data.validated</p>
    </div>
  );
}
--- END FILE: playground/src/workflows/data-processing/components/validate-data/ui.jsx ---
--- BEGIN FILE: playground/src/workflows/data-processing/config.js ---
export const config = {
  name: "data-processing",
  description: "A complex data workflow with branching and merging of events."
};
--- END FILE: playground/src/workflows/data-processing/config.js ---
--- BEGIN FILE: playground/src/workflows/data-processing/version.json ---
{
  "version": "1.0.0",
  "lastTested": "2025-01-01T00:00:00Z",
  "metrics": {}
}
--- END FILE: playground/src/workflows/data-processing/version.json ---
--- BEGIN FILE: playground/vite.config.js ---
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";

export default defineConfig({
  server: {
    proxy: {
      "/api": "http://localhost:3000",
    },
    hmr: {
      protocol: "ws",
      clientPort: 5173,
    },
  },
  plugins: [react()],
  resolve: {
    alias: {
      motia: path.resolve(__dirname, "../packages/motia/src"),
    },
  },
  optimizeDeps: {
    include: ["react", "react-dom", "motia/ui"],
    force: true,
  },
  build: {
    commonjsOptions: {
      include: [/motia/, /node_modules/],
    },
  },
});
--- END FILE: playground/vite.config.js ---
--- BEGIN FILE: pnpm-workspace.yaml ---
packages:
  - "packages/*"
  - "playground"
--- END FILE: pnpm-workspace.yaml ---
--- BEGIN FILE: vite.config.js ---
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";

export default defineConfig({
  root: path.resolve(__dirname, "src/ui"),
  plugins: [react()],
  server: {
    port: 5173,
    proxy: {
      "/api": "http://localhost:3000", // Proxy API calls to Node server
    },
  },
});
--- END FILE: vite.config.js ---
### FULL REPOSITORY CONTEXT END ###
